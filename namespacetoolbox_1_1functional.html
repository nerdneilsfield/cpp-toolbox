<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- BEGIN opengraph metadata -->
    <meta property="og:title" content="C++ Toolbox" />
    <meta
      property="og:image"
      content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"
    />
    <meta
      property="og:description"
      content="A collection of tools for C++ development."
    />
    <meta
      property="og:url"
      content="https://github.com/nerdneilsfield/cpp-toolbox"
    />
    <!-- END opengraph metadata -->
    <!-- BEGIN twitter metadata -->
    <meta
      name="twitter:image:src"
      content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452"
    />
    <meta name="twitter:title" content="Doxygen Awesome" />
    <meta
      name="twitter:description"
      content="Custom CSS theme for doxygen html-documentation with lots of customization parameters."
    />
    <!-- END twitter metadata -->
    <title>cpp-toolbox: toolbox::functional Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <link rel="icon" type="image/svg+xml" href="logo.drawio.svg" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script
      type="text/javascript"
      src="doxygen-awesome-darkmode-toggle.js"
    ></script>
    <script
      type="text/javascript"
      src="doxygen-awesome-fragment-copy-button.js"
    ></script>
    <script
      type="text/javascript"
      src="doxygen-awesome-paragraph-link.js"
    ></script>
    <script
      type="text/javascript"
      src="doxygen-awesome-interactive-toc.js"
    ></script>
    <script
      type="text/javascript"
      src="doxygen-awesome-tabs.js"
    ></script>
    <script
      type="text/javascript"
      src="toggle-alternative-theme.js"
    ></script>
    <script type="text/javascript">
      DoxygenAwesomeFragmentCopyButton.init();
      DoxygenAwesomeDarkModeToggle.init();
      DoxygenAwesomeParagraphLink.init();
      DoxygenAwesomeInteractiveToc.init();
      DoxygenAwesomeTabs.init();
    </script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
 <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <!-- https://tholman.com/github-corners/ -->
    <a
      href="https://github.com/nerdneilsfield/cpp-toolbox"
      class="github-corner"
      title="View source on GitHub"
      target="_blank"
      rel="noopener noreferrer"
    >
      <svg
        viewBox="0 0 250 250"
        width="40"
        height="40"
        style="position: absolute; top: 0; border: 0; right: 0; z-index: 99"
        aria-hidden="true"
      >
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
          d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
          fill="currentColor"
          style="transform-origin: 130px 106px"
          class="octo-arm"
        ></path>
        <path
          d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
          fill="currentColor"
          class="octo-body"
        ></path></svg></a
    ><style>
      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out;
      }
      @keyframes octocat-wave {
        0%,
        100% {
          transform: rotate(0);
        }
        20%,
        60% {
          transform: rotate(-25deg);
        }
        40%,
        80% {
          transform: rotate(10deg);
        }
      }
      @media (max-width: 500px) {
        .github-corner:hover .octo-arm {
          animation: none;
        }
        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out;
        }
      }
    </style>
    <div id="top">
      <!-- do not remove this div, it is closed by doxygen! -->
      <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
          <tbody>
            <tr style="height: 56px">
              <td id="projectalign" style="padding-left: 0.5em">
                <div id="projectname">
                  cpp-toolbox
                  &#160;<span id="projectnumber"
                    >0.0.1</span
                  >
                </div>
                <div id="projectbrief">A toolbox library for C++</div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <!-- end header part -->
    </div>
  </body>
</html>
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacetoolbox_1_1functional.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">toolbox::functional Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetoolbox_1_1functional_1_1detail" id="r_namespacetoolbox_1_1functional_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetoolbox_1_1functional_1_1detail__impl" id="r_namespacetoolbox_1_1functional_1_1detail__impl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional_1_1detail__impl.html">detail_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtoolbox_1_1functional_1_1_memoized_function_3_01_r_07_args_8_8_8_08_4.html">MemoizedFunction&lt; R(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemoizedFunction对特定函数签名的特化 / Specialization of MemoizedFunction for specific function signature 仅声明,实现在impl中 / Declaration only, definition in impl.  <a href="classtoolbox_1_1functional_1_1_memoized_function_3_01_r_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af8b28e1bd761680b1a9dcc57201c19ee" id="r_af8b28e1bd761680b1a9dcc57201c19ee"><td class="memTemplParams" colspan="2">template&lt;typename G , typename F &gt; </td></tr>
<tr class="memitem:af8b28e1bd761680b1a9dcc57201c19ee"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#af8b28e1bd761680b1a9dcc57201c19ee">compose</a> (G &amp;&amp;g, F &amp;&amp;f)</td></tr>
<tr class="memdesc:af8b28e1bd761680b1a9dcc57201c19ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">将两个函数组合成一个函数 / Composes two functions into a single function  <br /></td></tr>
<tr class="separator:af8b28e1bd761680b1a9dcc57201c19ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad505ee192c5c9ebd8d6d8d8628d888d5" id="r_ad505ee192c5c9ebd8d6d8d8628d888d5"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename... FRest&gt; </td></tr>
<tr class="memitem:ad505ee192c5c9ebd8d6d8d8628d888d5"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ad505ee192c5c9ebd8d6d8d8628d888d5">compose</a> (F1 &amp;&amp;f1, FRest &amp;&amp;... rest)</td></tr>
<tr class="memdesc:ad505ee192c5c9ebd8d6d8d8628d888d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">将多个函数组合成一个函数 / Composes multiple functions into a single function  <br /></td></tr>
<tr class="separator:ad505ee192c5c9ebd8d6d8d8628d888d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa30db9ce055ace2af1719e8c76a9b0" id="r_a8aa30db9ce055ace2af1719e8c76a9b0"><td class="memItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">compose</a> ()</td></tr>
<tr class="memdesc:a8aa30db9ce055ace2af1719e8c76a9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">空的compose函数,会抛出错误 / Empty compose function that throws an error  <br /></td></tr>
<tr class="separator:a8aa30db9ce055ace2af1719e8c76a9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc9e3b337e5a7e2d3d9eaac80939002" id="r_aecc9e3b337e5a7e2d3d9eaac80939002"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Arg1 &gt; </td></tr>
<tr class="memitem:aecc9e3b337e5a7e2d3d9eaac80939002"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#aecc9e3b337e5a7e2d3d9eaac80939002">bind_first</a> (F &amp;&amp;f, Arg1 &amp;&amp;arg1)</td></tr>
<tr class="memdesc:aecc9e3b337e5a7e2d3d9eaac80939002"><td class="mdescLeft">&#160;</td><td class="mdescRight">绑定函数的第一个参数 / Binds the first argument of a function  <br /></td></tr>
<tr class="separator:aecc9e3b337e5a7e2d3d9eaac80939002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab987da3dae28f15d0476a73bcb249c31" id="r_ab987da3dae28f15d0476a73bcb249c31"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab987da3dae28f15d0476a73bcb249c31"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a> (const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;f) -&gt; std::optional&lt; std::invoke_result_t&lt; F, const T &amp; &gt; &gt;</td></tr>
<tr class="memdesc:ab987da3dae28f15d0476a73bcb249c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional值上映射函数 / Maps a function over an optional value  <br /></td></tr>
<tr class="separator:ab987da3dae28f15d0476a73bcb249c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae876add04e6a887f8b62c69d6d6c798b" id="r_ae876add04e6a887f8b62c69d6d6c798b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ae876add04e6a887f8b62c69d6d6c798b"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ae876add04e6a887f8b62c69d6d6c798b">map</a> (std::optional&lt; T &gt; &amp;&amp;opt, F &amp;&amp;f) -&gt; std::optional&lt; std::invoke_result_t&lt; F, T &amp;&amp; &gt; &gt;</td></tr>
<tr class="memdesc:ae876add04e6a887f8b62c69d6d6c798b"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional右值上映射函数 / Maps a function over an optional rvalue  <br /></td></tr>
<tr class="separator:ae876add04e6a887f8b62c69d6d6c798b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea94163fa9d90b3c3a81a6f82fd31cd" id="r_abea94163fa9d90b3c3a81a6f82fd31cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:abea94163fa9d90b3c3a81a6f82fd31cd"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#abea94163fa9d90b3c3a81a6f82fd31cd">flatMap</a> (const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;f) -&gt; std::invoke_result_t&lt; F, const T &amp; &gt;</td></tr>
<tr class="memdesc:abea94163fa9d90b3c3a81a6f82fd31cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional值上平面映射函数 / Flat maps a function over an optional value  <br /></td></tr>
<tr class="separator:abea94163fa9d90b3c3a81a6f82fd31cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8866f4d6dc615d3c2b237adea3cf0810" id="r_a8866f4d6dc615d3c2b237adea3cf0810"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a8866f4d6dc615d3c2b237adea3cf0810"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a8866f4d6dc615d3c2b237adea3cf0810">flatMap</a> (std::optional&lt; T &gt; &amp;&amp;opt, F &amp;&amp;f) -&gt; std::invoke_result_t&lt; F, T &amp;&amp; &gt;</td></tr>
<tr class="memdesc:a8866f4d6dc615d3c2b237adea3cf0810"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional右值上平面映射函数 / Flat maps a function over an optional rvalue  <br /></td></tr>
<tr class="separator:a8866f4d6dc615d3c2b237adea3cf0810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e389bf7d4e1f5788548cd2784de28f" id="r_a50e389bf7d4e1f5788548cd2784de28f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a50e389bf7d4e1f5788548cd2784de28f"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a50e389bf7d4e1f5788548cd2784de28f">orElse</a> (const std::optional&lt; T &gt; &amp;opt, U &amp;&amp;default_value) -&gt; T</td></tr>
<tr class="memdesc:a50e389bf7d4e1f5788548cd2784de28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回包含的值或默认值 / Returns the contained value or a default  <br /></td></tr>
<tr class="separator:a50e389bf7d4e1f5788548cd2784de28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7a4acdd8ba7485698f9ea3e64920e9" id="r_a4a7a4acdd8ba7485698f9ea3e64920e9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a4a7a4acdd8ba7485698f9ea3e64920e9"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a4a7a4acdd8ba7485698f9ea3e64920e9">orElseGet</a> (const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;default_func) -&gt; T</td></tr>
<tr class="memdesc:a4a7a4acdd8ba7485698f9ea3e64920e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回包含的值或调用函数获取默认值 / Returns the contained value or calls function for default  <br /></td></tr>
<tr class="separator:a4a7a4acdd8ba7485698f9ea3e64920e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0c6694011c494298113d01b2b3e9de" id="r_a4e0c6694011c494298113d01b2b3e9de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a4e0c6694011c494298113d01b2b3e9de"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a> (const std::optional&lt; T &gt; &amp;opt, P &amp;&amp;p) -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:a4e0c6694011c494298113d01b2b3e9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">基于谓词过滤optional / Filters an optional based on a predicate  <br /></td></tr>
<tr class="separator:a4e0c6694011c494298113d01b2b3e9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887c36248685aa88197aa703787c30a8" id="r_a887c36248685aa88197aa703787c30a8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a887c36248685aa88197aa703787c30a8"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a887c36248685aa88197aa703787c30a8">filter</a> (std::optional&lt; T &gt; &amp;&amp;opt, P &amp;&amp;p) -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:a887c36248685aa88197aa703787c30a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">基于谓词过滤optional右值 / Filters an optional rvalue based on a predicate  <br /></td></tr>
<tr class="separator:a887c36248685aa88197aa703787c30a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f1f065e91d8b2571f14cc350983a02" id="r_a76f1f065e91d8b2571f14cc350983a02"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Fs&gt; </td></tr>
<tr class="memitem:a76f1f065e91d8b2571f14cc350983a02"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a> (const std::variant&lt; Ts... &gt; &amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a76f1f065e91d8b2571f14cc350983a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用访问器函数对variant进行模式匹配 / Pattern matches on a variant using visitor functions  <br /></td></tr>
<tr class="separator:a76f1f065e91d8b2571f14cc350983a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893e027e95dd95cee03d2c216de4205" id="r_a1893e027e95dd95cee03d2c216de4205"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Fs&gt; </td></tr>
<tr class="memitem:a1893e027e95dd95cee03d2c216de4205"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a1893e027e95dd95cee03d2c216de4205">match</a> (std::variant&lt; Ts... &gt; &amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a1893e027e95dd95cee03d2c216de4205"><td class="mdescLeft">&#160;</td><td class="mdescRight">对非const左值variant使用访问器函数进行匹配 / Match variant with visitor functions for non-const lvalue variant  <br /></td></tr>
<tr class="separator:a1893e027e95dd95cee03d2c216de4205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ce89a295a09678c2d0aa2dd9903ceb" id="r_a09ce89a295a09678c2d0aa2dd9903ceb"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Fs&gt; </td></tr>
<tr class="memitem:a09ce89a295a09678c2d0aa2dd9903ceb"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a09ce89a295a09678c2d0aa2dd9903ceb">match</a> (std::variant&lt; Ts... &gt; &amp;&amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a09ce89a295a09678c2d0aa2dd9903ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">对右值variant使用访问器函数进行匹配 / Match variant with visitor functions for rvalue variant  <br /></td></tr>
<tr class="separator:a09ce89a295a09678c2d0aa2dd9903ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470b06977505a96a3ee4ca05e6ca9907" id="r_a470b06977505a96a3ee4ca05e6ca9907"><td class="memTemplParams" colspan="2">template&lt;typename ResultVariant , typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:a470b06977505a96a3ee4ca05e6ca9907"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a470b06977505a96a3ee4ca05e6ca9907">map</a> (const std::variant&lt; Ts... &gt; &amp;var, F &amp;&amp;f) -&gt; ResultVariant</td></tr>
<tr class="memdesc:a470b06977505a96a3ee4ca05e6ca9907"><td class="mdescLeft">&#160;</td><td class="mdescRight">对variant中保存的值应用函数并在新variant中返回结果 / Apply a function to the value held by a variant and return result in a new variant  <br /></td></tr>
<tr class="separator:a470b06977505a96a3ee4ca05e6ca9907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e06cdbbc5ffdb751d6ec6b7b42dc2f3" id="r_a7e06cdbbc5ffdb751d6ec6b7b42dc2f3"><td class="memTemplParams" colspan="2">template&lt;typename ResultVariant , typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:a7e06cdbbc5ffdb751d6ec6b7b42dc2f3"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a7e06cdbbc5ffdb751d6ec6b7b42dc2f3">map</a> (std::variant&lt; Ts... &gt; &amp;var, F &amp;&amp;f) -&gt; ResultVariant</td></tr>
<tr class="memdesc:a7e06cdbbc5ffdb751d6ec6b7b42dc2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">对非const左值variant中保存的值应用函数 / Apply a function to the value held by a non-const lvalue variant  <br /></td></tr>
<tr class="separator:a7e06cdbbc5ffdb751d6ec6b7b42dc2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0df97865b75c205b0ae131de8b81688" id="r_ad0df97865b75c205b0ae131de8b81688"><td class="memTemplParams" colspan="2">template&lt;typename ResultVariant , typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:ad0df97865b75c205b0ae131de8b81688"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ad0df97865b75c205b0ae131de8b81688">map</a> (std::variant&lt; Ts... &gt; &amp;&amp;var, F &amp;&amp;f) -&gt; ResultVariant</td></tr>
<tr class="memdesc:ad0df97865b75c205b0ae131de8b81688"><td class="mdescLeft">&#160;</td><td class="mdescRight">对右值variant中保存的值应用函数 / Apply a function to the value held by an rvalue variant  <br /></td></tr>
<tr class="separator:ad0df97865b75c205b0ae131de8b81688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfa628faf0096a6a08a7a528161f86b" id="r_a7dfa628faf0096a6a08a7a528161f86b"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Func &gt; </td></tr>
<tr class="memitem:a7dfa628faf0096a6a08a7a528161f86b"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a7dfa628faf0096a6a08a7a528161f86b">map</a> (const Container &amp;input, Func &amp;&amp;f) -&gt; std::vector&lt; std::invoke_result_t&lt; Func, typename Container::const_reference &gt; &gt;</td></tr>
<tr class="memdesc:a7dfa628faf0096a6a08a7a528161f86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">对容器中的每个元素应用函数并返回结果向量 / Apply a function to each element in a container and return results in a vector  <br /></td></tr>
<tr class="separator:a7dfa628faf0096a6a08a7a528161f86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bfaacdb77bebe2eecb48d3ae6167da" id="r_a04bfaacdb77bebe2eecb48d3ae6167da"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:a04bfaacdb77bebe2eecb48d3ae6167da"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a04bfaacdb77bebe2eecb48d3ae6167da">filter</a> (const Container &amp;input, Predicate &amp;&amp;p) -&gt; std::vector&lt; typename Container::value_type &gt;</td></tr>
<tr class="memdesc:a04bfaacdb77bebe2eecb48d3ae6167da"><td class="mdescLeft">&#160;</td><td class="mdescRight">过滤满足谓词的容器元素 / Filter elements from a container that satisfy a predicate  <br /></td></tr>
<tr class="separator:a04bfaacdb77bebe2eecb48d3ae6167da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28234663d88d2ee0d2a8fc72044235e3" id="r_a28234663d88d2ee0d2a8fc72044235e3"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a28234663d88d2ee0d2a8fc72044235e3"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a> (const Container &amp;input, T identity, BinaryOp &amp;&amp;op) -&gt; T</td></tr>
<tr class="memdesc:a28234663d88d2ee0d2a8fc72044235e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用带初始值的二元操作归约容器元素 / Reduce container elements using a binary operation with initial value  <br /></td></tr>
<tr class="separator:a28234663d88d2ee0d2a8fc72044235e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a066d6a37ea371a922c192f5502bb1a26" id="r_a066d6a37ea371a922c192f5502bb1a26"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a066d6a37ea371a922c192f5502bb1a26"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a066d6a37ea371a922c192f5502bb1a26">reduce</a> (const Container &amp;input, BinaryOp &amp;&amp;op) -&gt; typename Container::value_type</td></tr>
<tr class="memdesc:a066d6a37ea371a922c192f5502bb1a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用二元操作归约非空容器元素 / Reduce non-empty container elements using a binary operation  <br /></td></tr>
<tr class="separator:a066d6a37ea371a922c192f5502bb1a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac747cafdf73d872cb3827c20f3180ade" id="r_ac747cafdf73d872cb3827c20f3180ade"><td class="memTemplParams" colspan="2">template&lt;typename... Containers&gt; </td></tr>
<tr class="memitem:ac747cafdf73d872cb3827c20f3180ade"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ac747cafdf73d872cb3827c20f3180ade">zip</a> (const Containers &amp;... containers) -&gt; std::vector&lt; std::tuple&lt; decltype(*std::cbegin(std::declval&lt; const Containers &amp; &gt;()))... &gt; &gt;</td></tr>
<tr class="memdesc:ac747cafdf73d872cb3827c20f3180ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">将多个容器压缩成元组向量 / Zip multiple containers into a vector of tuples  <br /></td></tr>
<tr class="separator:ac747cafdf73d872cb3827c20f3180ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb6acc3f4d90809e63e519440e55b7c" id="r_a4fb6acc3f4d90809e63e519440e55b7c"><td class="memTemplParams" colspan="2">template&lt;typename ContainerKeys , typename ContainerValues , typename Key  = typename std::decay_t&lt;ContainerKeys&gt;::value_type, typename Value  = typename std::decay_t&lt;ContainerValues&gt;::value_type, typename Hash  = std::hash&lt;Key&gt;, typename KeyEqual  = std::equal_to&lt;Key&gt;, typename Alloc  = std::allocator&lt;std::pair&lt;const Key, Value&gt;&gt;&gt; </td></tr>
<tr class="memitem:a4fb6acc3f4d90809e63e519440e55b7c"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a4fb6acc3f4d90809e63e519440e55b7c">zip_to_unordered_map</a> (const ContainerKeys &amp;keys, const ContainerValues &amp;values) -&gt; std::unordered_map&lt; Key, Value, Hash, KeyEqual, Alloc &gt;</td></tr>
<tr class="memdesc:a4fb6acc3f4d90809e63e519440e55b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">将两个序列压缩成无序映射 / Zip two sequences into an unordered_map  <br /></td></tr>
<tr class="separator:a4fb6acc3f4d90809e63e519440e55b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3f8127f603901d466318d6aaff381f" id="r_a8c3f8127f603901d466318d6aaff381f"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename Func &gt; </td></tr>
<tr class="memitem:a8c3f8127f603901d466318d6aaff381f"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a8c3f8127f603901d466318d6aaff381f">memoize</a> (Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a8c3f8127f603901d466318d6aaff381f"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建带显式签名的记忆化函数 / Create a memoized function with explicit signature  <br /></td></tr>
<tr class="separator:a8c3f8127f603901d466318d6aaff381f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae451cc75b6a39fd16d3c1c680988706e" id="r_ae451cc75b6a39fd16d3c1c680988706e"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, typename Func &gt; </td></tr>
<tr class="memitem:ae451cc75b6a39fd16d3c1c680988706e"><td class="memTemplItemLeft" align="right" valign="top">CPP_TOOLBOX_EXPORT auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ae451cc75b6a39fd16d3c1c680988706e">memoize_explicit</a> (Func &amp;&amp;f) -&gt; std::function&lt; R(Args...)&gt;</td></tr>
<tr class="memdesc:ae451cc75b6a39fd16d3c1c680988706e"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建带显式返回和参数类型的记忆化函数 / Create a memoized function with explicit return and argument types  <br /></td></tr>
<tr class="separator:ae451cc75b6a39fd16d3c1c680988706e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73614e7a6d879b7e2ff3be342d01f832" id="r_a73614e7a6d879b7e2ff3be342d01f832"><td class="memTemplParams" colspan="2">template&lt;typename G , typename F &gt; </td></tr>
<tr class="memitem:a73614e7a6d879b7e2ff3be342d01f832"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a73614e7a6d879b7e2ff3be342d01f832">compose</a> (G &amp;&amp;g, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a73614e7a6d879b7e2ff3be342d01f832"><td class="mdescLeft">&#160;</td><td class="mdescRight">将两个函数组合成一个函数 / Composes two functions into a single function  <br /></td></tr>
<tr class="separator:a73614e7a6d879b7e2ff3be342d01f832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62235f5b9cd7bdf5f6754cb243e703a4" id="r_a62235f5b9cd7bdf5f6754cb243e703a4"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename... FRest&gt; </td></tr>
<tr class="memitem:a62235f5b9cd7bdf5f6754cb243e703a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a62235f5b9cd7bdf5f6754cb243e703a4">compose</a> (F1 &amp;&amp;f1, FRest &amp;&amp;... rest)</td></tr>
<tr class="memdesc:a62235f5b9cd7bdf5f6754cb243e703a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">将多个函数组合成一个函数 / Composes multiple functions into a single function  <br /></td></tr>
<tr class="separator:a62235f5b9cd7bdf5f6754cb243e703a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0ae6022a29dcda8ebca974573bf70a" id="r_a1e0ae6022a29dcda8ebca974573bf70a"><td class="memTemplParams" colspan="2">template&lt;typename F , typename Arg1 &gt; </td></tr>
<tr class="memitem:a1e0ae6022a29dcda8ebca974573bf70a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a1e0ae6022a29dcda8ebca974573bf70a">bind_first</a> (F &amp;&amp;f, Arg1 &amp;&amp;arg1)</td></tr>
<tr class="memdesc:a1e0ae6022a29dcda8ebca974573bf70a"><td class="mdescLeft">&#160;</td><td class="mdescRight">绑定函数的第一个参数 / Binds the first argument of a function  <br /></td></tr>
<tr class="separator:a1e0ae6022a29dcda8ebca974573bf70a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac473d11cdff7b5498e4d4562534d6cd8" id="r_ac473d11cdff7b5498e4d4562534d6cd8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ac473d11cdff7b5498e4d4562534d6cd8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ac473d11cdff7b5498e4d4562534d6cd8">map</a> (const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;f) -&gt; std::optional&lt; std::invoke_result_t&lt; F, const T &amp; &gt; &gt;</td></tr>
<tr class="memdesc:ac473d11cdff7b5498e4d4562534d6cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional值上映射函数 / Maps a function over an optional value  <br /></td></tr>
<tr class="separator:ac473d11cdff7b5498e4d4562534d6cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8327d7a971ca42627faa5b66ad81012" id="r_af8327d7a971ca42627faa5b66ad81012"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:af8327d7a971ca42627faa5b66ad81012"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#af8327d7a971ca42627faa5b66ad81012">map</a> (std::optional&lt; T &gt; &amp;&amp;opt, F &amp;&amp;f) -&gt; std::optional&lt; std::invoke_result_t&lt; F, T &amp;&amp; &gt; &gt;</td></tr>
<tr class="memdesc:af8327d7a971ca42627faa5b66ad81012"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional右值上映射函数 / Maps a function over an optional rvalue  <br /></td></tr>
<tr class="separator:af8327d7a971ca42627faa5b66ad81012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424450bf0ce67fb53903b20dee8b1765" id="r_a424450bf0ce67fb53903b20dee8b1765"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a424450bf0ce67fb53903b20dee8b1765"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a424450bf0ce67fb53903b20dee8b1765">flatMap</a> (const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;f) -&gt; std::invoke_result_t&lt; F, const T &amp; &gt;</td></tr>
<tr class="memdesc:a424450bf0ce67fb53903b20dee8b1765"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional值上平面映射函数 / Flat maps a function over an optional value  <br /></td></tr>
<tr class="separator:a424450bf0ce67fb53903b20dee8b1765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f50536887abe0448cb0484c4ec3abb" id="r_a20f50536887abe0448cb0484c4ec3abb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a20f50536887abe0448cb0484c4ec3abb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a20f50536887abe0448cb0484c4ec3abb">flatMap</a> (std::optional&lt; T &gt; &amp;&amp;opt, F &amp;&amp;f) -&gt; std::invoke_result_t&lt; F, T &amp;&amp; &gt;</td></tr>
<tr class="memdesc:a20f50536887abe0448cb0484c4ec3abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">在optional右值上平面映射函数 / Flat maps a function over an optional rvalue  <br /></td></tr>
<tr class="separator:a20f50536887abe0448cb0484c4ec3abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b4c848e551d917eebb0bebfa50fc66" id="r_ad0b4c848e551d917eebb0bebfa50fc66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ad0b4c848e551d917eebb0bebfa50fc66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ad0b4c848e551d917eebb0bebfa50fc66">orElse</a> (const std::optional&lt; T &gt; &amp;opt, U &amp;&amp;default_value) -&gt; T</td></tr>
<tr class="memdesc:ad0b4c848e551d917eebb0bebfa50fc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回包含的值或默认值 / Returns the contained value or a default  <br /></td></tr>
<tr class="separator:ad0b4c848e551d917eebb0bebfa50fc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1baad6982df3cde2d03724aa870e274" id="r_ae1baad6982df3cde2d03724aa870e274"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ae1baad6982df3cde2d03724aa870e274"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ae1baad6982df3cde2d03724aa870e274">orElseGet</a> (const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;default_func) -&gt; T</td></tr>
<tr class="memdesc:ae1baad6982df3cde2d03724aa870e274"><td class="mdescLeft">&#160;</td><td class="mdescRight">返回包含的值或调用函数获取默认值 / Returns the contained value or calls function for default  <br /></td></tr>
<tr class="separator:ae1baad6982df3cde2d03724aa870e274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ecec782b192847390f333b4af52dc3" id="r_a68ecec782b192847390f333b4af52dc3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:a68ecec782b192847390f333b4af52dc3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a68ecec782b192847390f333b4af52dc3">filter</a> (const std::optional&lt; T &gt; &amp;opt, P &amp;&amp;p) -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:a68ecec782b192847390f333b4af52dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">基于谓词过滤optional / Filters an optional based on a predicate  <br /></td></tr>
<tr class="separator:a68ecec782b192847390f333b4af52dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb40cb4be7d2e760e5cf545c558aa87f" id="r_adb40cb4be7d2e760e5cf545c558aa87f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:adb40cb4be7d2e760e5cf545c558aa87f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#adb40cb4be7d2e760e5cf545c558aa87f">filter</a> (std::optional&lt; T &gt; &amp;&amp;opt, P &amp;&amp;p) -&gt; std::optional&lt; T &gt;</td></tr>
<tr class="memdesc:adb40cb4be7d2e760e5cf545c558aa87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">基于谓词过滤optional右值 / Filters an optional rvalue based on a predicate  <br /></td></tr>
<tr class="separator:adb40cb4be7d2e760e5cf545c558aa87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc20d2de6408ff5e8bda0b7174c2bf9" id="r_adfc20d2de6408ff5e8bda0b7174c2bf9"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Fs&gt; </td></tr>
<tr class="memitem:adfc20d2de6408ff5e8bda0b7174c2bf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#adfc20d2de6408ff5e8bda0b7174c2bf9">match</a> (const std::variant&lt; Ts... &gt; &amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:adfc20d2de6408ff5e8bda0b7174c2bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用访问器函数对variant进行模式匹配 / Pattern matches on a variant using visitor functions  <br /></td></tr>
<tr class="separator:adfc20d2de6408ff5e8bda0b7174c2bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31150fb88996d76590ccc35593c7b70d" id="r_a31150fb88996d76590ccc35593c7b70d"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Fs&gt; </td></tr>
<tr class="memitem:a31150fb88996d76590ccc35593c7b70d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a31150fb88996d76590ccc35593c7b70d">match</a> (std::variant&lt; Ts... &gt; &amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a31150fb88996d76590ccc35593c7b70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">对非const左值variant使用访问器函数进行匹配 / Match variant with visitor functions for non-const lvalue variant  <br /></td></tr>
<tr class="separator:a31150fb88996d76590ccc35593c7b70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db12c30c97eddfdbe5bb80179b94f4" id="r_a48db12c30c97eddfdbe5bb80179b94f4"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename... Fs&gt; </td></tr>
<tr class="memitem:a48db12c30c97eddfdbe5bb80179b94f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a48db12c30c97eddfdbe5bb80179b94f4">match</a> (std::variant&lt; Ts... &gt; &amp;&amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</td></tr>
<tr class="memdesc:a48db12c30c97eddfdbe5bb80179b94f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">对右值variant使用访问器函数进行匹配 / Match variant with visitor functions for rvalue variant  <br /></td></tr>
<tr class="separator:a48db12c30c97eddfdbe5bb80179b94f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a3a49ee3d8b5063e93e806d350db95" id="r_a65a3a49ee3d8b5063e93e806d350db95"><td class="memTemplParams" colspan="2">template&lt;typename ResultVariant , typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:a65a3a49ee3d8b5063e93e806d350db95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a65a3a49ee3d8b5063e93e806d350db95">map</a> (const std::variant&lt; Ts... &gt; &amp;var, F &amp;&amp;f) -&gt; ResultVariant</td></tr>
<tr class="memdesc:a65a3a49ee3d8b5063e93e806d350db95"><td class="mdescLeft">&#160;</td><td class="mdescRight">对variant中保存的值应用函数并在新variant中返回结果 / Apply a function to the value held by a variant and return result in a new variant  <br /></td></tr>
<tr class="separator:a65a3a49ee3d8b5063e93e806d350db95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0946f6ce3008057d1e5a6c5ee9b120" id="r_abe0946f6ce3008057d1e5a6c5ee9b120"><td class="memTemplParams" colspan="2">template&lt;typename ResultVariant , typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:abe0946f6ce3008057d1e5a6c5ee9b120"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#abe0946f6ce3008057d1e5a6c5ee9b120">map</a> (std::variant&lt; Ts... &gt; &amp;var, F &amp;&amp;f) -&gt; ResultVariant</td></tr>
<tr class="memdesc:abe0946f6ce3008057d1e5a6c5ee9b120"><td class="mdescLeft">&#160;</td><td class="mdescRight">对非const左值variant中保存的值应用函数 / Apply a function to the value held by a non-const lvalue variant  <br /></td></tr>
<tr class="separator:abe0946f6ce3008057d1e5a6c5ee9b120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec605443bd2b2ee732a30baf2427805" id="r_a6ec605443bd2b2ee732a30baf2427805"><td class="memTemplParams" colspan="2">template&lt;typename ResultVariant , typename... Ts, typename F &gt; </td></tr>
<tr class="memitem:a6ec605443bd2b2ee732a30baf2427805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a6ec605443bd2b2ee732a30baf2427805">map</a> (std::variant&lt; Ts... &gt; &amp;&amp;var, F &amp;&amp;f) -&gt; ResultVariant</td></tr>
<tr class="memdesc:a6ec605443bd2b2ee732a30baf2427805"><td class="mdescLeft">&#160;</td><td class="mdescRight">对右值variant中保存的值应用函数 / Apply a function to the value held by an rvalue variant  <br /></td></tr>
<tr class="separator:a6ec605443bd2b2ee732a30baf2427805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8acf31a60d51288362956265e3addf2" id="r_af8acf31a60d51288362956265e3addf2"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Func &gt; </td></tr>
<tr class="memitem:af8acf31a60d51288362956265e3addf2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#af8acf31a60d51288362956265e3addf2">map</a> (const Container &amp;input, Func &amp;&amp;f) -&gt; std::vector&lt; std::invoke_result_t&lt; Func, typename Container::const_reference &gt; &gt;</td></tr>
<tr class="memdesc:af8acf31a60d51288362956265e3addf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">对容器中的每个元素应用函数并返回结果向量 / Apply a function to each element in a container and return results in a vector  <br /></td></tr>
<tr class="separator:af8acf31a60d51288362956265e3addf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf8da56d5d7e9e09986db066318b5cf" id="r_aaaf8da56d5d7e9e09986db066318b5cf"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:aaaf8da56d5d7e9e09986db066318b5cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#aaaf8da56d5d7e9e09986db066318b5cf">filter</a> (const Container &amp;input, Predicate &amp;&amp;p) -&gt; std::vector&lt; typename Container::value_type &gt;</td></tr>
<tr class="memdesc:aaaf8da56d5d7e9e09986db066318b5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">过滤满足谓词的容器元素 / Filter elements from a container that satisfy a predicate  <br /></td></tr>
<tr class="separator:aaaf8da56d5d7e9e09986db066318b5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3f2ee7ec3d87022b31c2f07743c4e6" id="r_aea3f2ee7ec3d87022b31c2f07743c4e6"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename T , typename BinaryOp &gt; </td></tr>
<tr class="memitem:aea3f2ee7ec3d87022b31c2f07743c4e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#aea3f2ee7ec3d87022b31c2f07743c4e6">reduce</a> (const Container &amp;input, T identity, BinaryOp &amp;&amp;op) -&gt; T</td></tr>
<tr class="memdesc:aea3f2ee7ec3d87022b31c2f07743c4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用带初始值的二元操作归约容器元素 / Reduce container elements using a binary operation with initial value  <br /></td></tr>
<tr class="separator:aea3f2ee7ec3d87022b31c2f07743c4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b525e7afccde1000246e289b1469af" id="r_a10b525e7afccde1000246e289b1469af"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename BinaryOp &gt; </td></tr>
<tr class="memitem:a10b525e7afccde1000246e289b1469af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a10b525e7afccde1000246e289b1469af">reduce</a> (const Container &amp;input, BinaryOp &amp;&amp;op) -&gt; typename Container::value_type</td></tr>
<tr class="memdesc:a10b525e7afccde1000246e289b1469af"><td class="mdescLeft">&#160;</td><td class="mdescRight">使用二元操作归约非空容器元素 / Reduce non-empty container elements using a binary operation  <br /></td></tr>
<tr class="separator:a10b525e7afccde1000246e289b1469af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e716e0651b55b72aadf0561117a6bb" id="r_af1e716e0651b55b72aadf0561117a6bb"><td class="memTemplParams" colspan="2">template&lt;typename... Containers&gt; </td></tr>
<tr class="memitem:af1e716e0651b55b72aadf0561117a6bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#af1e716e0651b55b72aadf0561117a6bb">zip</a> (const Containers &amp;... containers) -&gt; std::vector&lt; std::tuple&lt; decltype(*std::cbegin(std::declval&lt; const Containers &amp; &gt;()))... &gt; &gt;</td></tr>
<tr class="memdesc:af1e716e0651b55b72aadf0561117a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">将多个容器压缩成元组向量 / Zip multiple containers into a vector of tuples  <br /></td></tr>
<tr class="separator:af1e716e0651b55b72aadf0561117a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04b877b2a05cd06d327adb9f9bd273ea" id="r_a04b877b2a05cd06d327adb9f9bd273ea"><td class="memTemplParams" colspan="2">template&lt;typename ContainerKeys , typename ContainerValues , typename Key , typename Value , typename Hash , typename KeyEqual , typename Alloc &gt; </td></tr>
<tr class="memitem:a04b877b2a05cd06d327adb9f9bd273ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a04b877b2a05cd06d327adb9f9bd273ea">zip_to_unordered_map</a> (const ContainerKeys &amp;keys, const ContainerValues &amp;values) -&gt; std::unordered_map&lt; Key, Value, Hash, KeyEqual, Alloc &gt;</td></tr>
<tr class="memdesc:a04b877b2a05cd06d327adb9f9bd273ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">将两个序列压缩成无序映射 / Zip two sequences into an unordered_map  <br /></td></tr>
<tr class="separator:a04b877b2a05cd06d327adb9f9bd273ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ae7d48b6cf42eb8a27dbf3a970167b" id="r_a67ae7d48b6cf42eb8a27dbf3a970167b"><td class="memTemplParams" colspan="2">template&lt;typename Signature , typename Func &gt; </td></tr>
<tr class="memitem:a67ae7d48b6cf42eb8a27dbf3a970167b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#a67ae7d48b6cf42eb8a27dbf3a970167b">memoize</a> (Func &amp;&amp;f)</td></tr>
<tr class="memdesc:a67ae7d48b6cf42eb8a27dbf3a970167b"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建带显式签名的记忆化函数 / Create a memoized function with explicit signature  <br /></td></tr>
<tr class="separator:a67ae7d48b6cf42eb8a27dbf3a970167b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ca279b16162dbbf7042fc2681bdba7" id="r_af4ca279b16162dbbf7042fc2681bdba7"><td class="memTemplParams" colspan="2">template&lt;typename R , typename... Args, typename Func &gt; </td></tr>
<tr class="memitem:af4ca279b16162dbbf7042fc2681bdba7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#af4ca279b16162dbbf7042fc2681bdba7">memoize_explicit</a> (Func &amp;&amp;f) -&gt; std::function&lt; R(Args...)&gt;</td></tr>
<tr class="memdesc:af4ca279b16162dbbf7042fc2681bdba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">创建带显式返回和参数类型的记忆化函数 / Create a memoized function with explicit return and argument types  <br /></td></tr>
<tr class="separator:af4ca279b16162dbbf7042fc2681bdba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae72a328600ef1342629b7fe3bab4d88b" id="r_ae72a328600ef1342629b7fe3bab4d88b"><td class="memTemplParams" colspan="2">template&lt;typename Signature &gt; </td></tr>
<tr class="memitem:ae72a328600ef1342629b7fe3bab4d88b"><td class="memTemplItemLeft" align="right" valign="top">class CPP_TOOLBOX_EXPORT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetoolbox_1_1functional.html#ae72a328600ef1342629b7fe3bab4d88b">MemoizedFunction</a></td></tr>
<tr class="memdesc:ae72a328600ef1342629b7fe3bab4d88b"><td class="mdescLeft">&#160;</td><td class="mdescRight">缓存函数结果的记忆化函数类 / Memoized function class that caches function results  <br /></td></tr>
<tr class="separator:ae72a328600ef1342629b7fe3bab4d88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="aecc9e3b337e5a7e2d3d9eaac80939002" name="aecc9e3b337e5a7e2d3d9eaac80939002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc9e3b337e5a7e2d3d9eaac80939002">&#9670;&#160;</a></span>bind_first() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::bind_first </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>绑定函数的第一个参数 / Binds the first argument of a function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>函数类型 / Function type </td></tr>
    <tr><td class="paramname">Arg1</td><td>第一个参数的类型 / Type of first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>要绑定的函数 / Function to bind </td></tr>
    <tr><td class="paramname">arg1</td><td>要绑定为第一个参数的值 / Value to bind as first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>第一个参数被绑定的函数 / Function with first argument bound</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 绑定第一个参数的示例 / Example of binding first argument</span></div>
<div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) { <span class="keywordflow">return</span> x / y; };</div>
<div class="line"><span class="keyword">auto</span> divide_10_by = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#aecc9e3b337e5a7e2d3d9eaac80939002">bind_first</a>(divide, 10);</div>
<div class="line"><span class="keywordtype">int</span> result = divide_10_by(2); <span class="comment">// 返回5 / Returns 5</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_aecc9e3b337e5a7e2d3d9eaac80939002"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#aecc9e3b337e5a7e2d3d9eaac80939002">toolbox::functional::bind_first</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto bind_first(F &amp;&amp;f, Arg1 &amp;&amp;arg1)</div><div class="ttdoc">绑定函数的第一个参数 / Binds the first argument of a function</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:142</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1e0ae6022a29dcda8ebca974573bf70a" name="a1e0ae6022a29dcda8ebca974573bf70a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0ae6022a29dcda8ebca974573bf70a">&#9670;&#160;</a></span>bind_first() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename Arg1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::bind_first </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arg1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>绑定函数的第一个参数 / Binds the first argument of a function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>函数类型 / Function type </td></tr>
    <tr><td class="paramname">Arg1</td><td>第一个参数的类型 / Type of first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>要绑定的函数 / Function to bind </td></tr>
    <tr><td class="paramname">arg1</td><td>要绑定为第一个参数的值 / Value to bind as first argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>第一个参数被绑定的函数 / Function with first argument bound</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 绑定第一个参数的示例 / Example of binding first argument</span></div>
<div class="line"><span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y) { <span class="keywordflow">return</span> x / y; };</div>
<div class="line"><span class="keyword">auto</span> divide_10_by = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#aecc9e3b337e5a7e2d3d9eaac80939002">bind_first</a>(divide, 10);</div>
<div class="line"><span class="keywordtype">int</span> result = divide_10_by(2); <span class="comment">// 返回5 / Returns 5</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8aa30db9ce055ace2af1719e8c76a9b0" name="a8aa30db9ce055ace2af1719e8c76a9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa30db9ce055ace2af1719e8c76a9b0">&#9670;&#160;</a></span>compose() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::compose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>空的compose函数,会抛出错误 / Empty compose function that throws an error </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::logic_error</td><td>当被调用时 / when called</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordflow">try</span> {</div>
<div class="line">  <span class="keyword">auto</span> empty = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">compose</a>();</div>
<div class="line">} <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::logic_error&amp; e) {</div>
<div class="line">  <span class="comment">// 异常被捕获 / Exception caught</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a8aa30db9ce055ace2af1719e8c76a9b0"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">toolbox::functional::compose</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto compose()</div><div class="ttdoc">空的compose函数,会抛出错误 / Empty compose function that throws an error</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:136</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad505ee192c5c9ebd8d6d8d8628d888d5" name="ad505ee192c5c9ebd8d6d8d8628d888d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad505ee192c5c9ebd8d6d8d8628d888d5">&#9670;&#160;</a></span>compose() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename... FRest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::compose </td>
          <td>(</td>
          <td class="paramtype">F1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将多个函数组合成一个函数 / Composes multiple functions into a single function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F1</td><td>第一个(最外层)函数类型 / Type of first (outermost) function </td></tr>
    <tr><td class="paramname">FRest</td><td>剩余函数类型 / Types of remaining functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>第一个函数 / First function </td></tr>
    <tr><td class="paramname">rest</td><td>剩余函数 / Remaining functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>从右到左应用函数的函数 / A function that applies functions from right to left</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 多函数组合示例 / Example of multiple function composition</span></div>
<div class="line"><span class="keyword">auto</span> add_one = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x + 1; };</div>
<div class="line"><span class="keyword">auto</span> multiply_two = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; };</div>
<div class="line"><span class="keyword">auto</span> square = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; };</div>
<div class="line"><span class="keyword">auto</span> composed = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">compose</a>(square, multiply_two, add_one);</div>
<div class="line"><span class="keywordtype">int</span> result = composed(5); <span class="comment">// 返回144: ((5 + 1) * 2)^2 / Returns 144: ((5 + 1)</span></div>
<div class="line">* 2)^2</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a62235f5b9cd7bdf5f6754cb243e703a4" name="a62235f5b9cd7bdf5f6754cb243e703a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62235f5b9cd7bdf5f6754cb243e703a4">&#9670;&#160;</a></span>compose() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F1 , typename... FRest&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::compose </td>
          <td>(</td>
          <td class="paramtype">F1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将多个函数组合成一个函数 / Composes multiple functions into a single function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F1</td><td>第一个(最外层)函数类型 / Type of first (outermost) function </td></tr>
    <tr><td class="paramname">FRest</td><td>剩余函数类型 / Types of remaining functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>第一个函数 / First function </td></tr>
    <tr><td class="paramname">rest</td><td>剩余函数 / Remaining functions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>从右到左应用函数的函数 / A function that applies functions from right to left</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 多函数组合示例 / Example of multiple function composition</span></div>
<div class="line"><span class="keyword">auto</span> add_one = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x + 1; };</div>
<div class="line"><span class="keyword">auto</span> multiply_two = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; };</div>
<div class="line"><span class="keyword">auto</span> square = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; };</div>
<div class="line"><span class="keyword">auto</span> composed = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">compose</a>(square, multiply_two, add_one);</div>
<div class="line"><span class="keywordtype">int</span> result = composed(5); <span class="comment">// 返回144: ((5 + 1) * 2)^2 / Returns 144: ((5 + 1)</span></div>
<div class="line">* 2)^2</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af8b28e1bd761680b1a9dcc57201c19ee" name="af8b28e1bd761680b1a9dcc57201c19ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b28e1bd761680b1a9dcc57201c19ee">&#9670;&#160;</a></span>compose() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::compose </td>
          <td>(</td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将两个函数组合成一个函数 / Composes two functions into a single function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>外层函数类型 / Type of outer function </td></tr>
    <tr><td class="paramname">F</td><td>内层函数类型 / Type of inner function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>外层函数 / Outer function </td></tr>
    <tr><td class="paramname">f</td><td>内层函数 / Inner function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>先应用f再应用g的函数 / A function that applies f then g</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 函数组合示例 / Example of function composition</span></div>
<div class="line"><span class="keyword">auto</span> add_one = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x + 1; };</div>
<div class="line"><span class="keyword">auto</span> multiply_two = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; };</div>
<div class="line"><span class="keyword">auto</span> composed = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">compose</a>(multiply_two, add_one);</div>
<div class="line"><span class="keywordtype">int</span> result = composed(5); <span class="comment">// 返回12: ((5 + 1) * 2) / Returns 12: ((5 + 1) *</span></div>
<div class="line">2)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a73614e7a6d879b7e2ff3be342d01f832" name="a73614e7a6d879b7e2ff3be342d01f832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73614e7a6d879b7e2ff3be342d01f832">&#9670;&#160;</a></span>compose() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename G , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::compose </td>
          <td>(</td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将两个函数组合成一个函数 / Composes two functions into a single function </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">G</td><td>外层函数类型 / Type of outer function </td></tr>
    <tr><td class="paramname">F</td><td>内层函数类型 / Type of inner function </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>外层函数 / Outer function </td></tr>
    <tr><td class="paramname">f</td><td>内层函数 / Inner function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>先应用f再应用g的函数 / A function that applies f then g</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 函数组合示例 / Example of function composition</span></div>
<div class="line"><span class="keyword">auto</span> add_one = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x + 1; };</div>
<div class="line"><span class="keyword">auto</span> multiply_two = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; };</div>
<div class="line"><span class="keyword">auto</span> composed = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a8aa30db9ce055ace2af1719e8c76a9b0">compose</a>(multiply_two, add_one);</div>
<div class="line"><span class="keywordtype">int</span> result = composed(5); <span class="comment">// 返回12: ((5 + 1) * 2) / Returns 12: ((5 + 1) *</span></div>
<div class="line">2)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a04bfaacdb77bebe2eecb48d3ae6167da" name="a04bfaacdb77bebe2eecb48d3ae6167da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bfaacdb77bebe2eecb48d3ae6167da">&#9670;&#160;</a></span>filter() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::filter </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::vector&lt; typename Container::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>过滤满足谓词的容器元素 / Filter elements from a container that satisfy a predicate </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">Predicate</td><td>谓词函数类型 / Predicate function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器 / Input container </td></tr>
    <tr><td class="paramname">p</td><td>返回bool的谓词函数 / Predicate function returning bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含满足谓词p的元素的向量 / Vector containing elements that satisfy predicate p</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 过滤偶数 / Filter even numbers</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> evens = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(nums, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });</div>
<div class="line"><span class="comment">// 返回 {2, 4} / Returns {2, 4}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 过滤长字符串 / Filter long strings</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bb&quot;</span>, <span class="stringliteral">&quot;ccc&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> long_strs = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(strs, [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s) { <span class="keywordflow">return</span> s.length() &gt; 1; });</div>
<div class="line"><span class="comment">// 返回 {&quot;bb&quot;, &quot;ccc&quot;} / Returns {&quot;bb&quot;, &quot;ccc&quot;}</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a4e0c6694011c494298113d01b2b3e9de"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">toolbox::functional::filter</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto filter(const std::optional&lt; T &gt; &amp;opt, P &amp;&amp;p) -&gt; std::optional&lt; T &gt;</div><div class="ttdoc">基于谓词过滤optional / Filters an optional based on a predicate</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:242</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aaaf8da56d5d7e9e09986db066318b5cf" name="aaaf8da56d5d7e9e09986db066318b5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf8da56d5d7e9e09986db066318b5cf">&#9670;&#160;</a></span>filter() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::filter </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::vector&lt; typename Container::value_type &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>过滤满足谓词的容器元素 / Filter elements from a container that satisfy a predicate </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">Predicate</td><td>谓词函数类型 / Predicate function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器 / Input container </td></tr>
    <tr><td class="paramname">p</td><td>返回bool的谓词函数 / Predicate function returning bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含满足谓词p的元素的向量 / Vector containing elements that satisfy predicate p</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 过滤偶数 / Filter even numbers</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};</div>
<div class="line"><span class="keyword">auto</span> evens = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(nums, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; });</div>
<div class="line"><span class="comment">// 返回 {2, 4} / Returns {2, 4}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 过滤长字符串 / Filter long strings</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bb&quot;</span>, <span class="stringliteral">&quot;ccc&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> long_strs = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(strs, [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s) { <span class="keywordflow">return</span> s.length() &gt; 1; });</div>
<div class="line"><span class="comment">// 返回 {&quot;bb&quot;, &quot;ccc&quot;} / Returns {&quot;bb&quot;, &quot;ccc&quot;}</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4e0c6694011c494298113d01b2b3e9de" name="a4e0c6694011c494298113d01b2b3e9de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0c6694011c494298113d01b2b3e9de">&#9670;&#160;</a></span>filter() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::filter </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基于谓词过滤optional / Filters an optional based on a predicate </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">P</td><td>谓词类型 / Predicate type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要过滤的optional / Optional to filter </td></tr>
    <tr><td class="paramname">p</td><td>要应用的谓词 / Predicate to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果谓词返回true则为optional,否则为空optional / Optional if predicate returns true, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 过滤optional的示例 / Example of filtering optional</span></div>
<div class="line">std::optional&lt;int&gt; opt(42);</div>
<div class="line"><span class="keyword">auto</span> is_even = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; };</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(opt, is_even); <span class="comment">// 包含42 / Contains 42</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a68ecec782b192847390f333b4af52dc3" name="a68ecec782b192847390f333b4af52dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ecec782b192847390f333b4af52dc3">&#9670;&#160;</a></span>filter() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::filter </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基于谓词过滤optional / Filters an optional based on a predicate </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">P</td><td>谓词类型 / Predicate type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要过滤的optional / Optional to filter </td></tr>
    <tr><td class="paramname">p</td><td>要应用的谓词 / Predicate to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果谓词返回true则为optional,否则为空optional / Optional if predicate returns true, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 过滤optional的示例 / Example of filtering optional</span></div>
<div class="line">std::optional&lt;int&gt; opt(42);</div>
<div class="line"><span class="keyword">auto</span> is_even = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0; };</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(opt, is_even); <span class="comment">// 包含42 / Contains 42</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a887c36248685aa88197aa703787c30a8" name="a887c36248685aa88197aa703787c30a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887c36248685aa88197aa703787c30a8">&#9670;&#160;</a></span>filter() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::filter </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基于谓词过滤optional右值 / Filters an optional rvalue based on a predicate </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">P</td><td>谓词类型 / Predicate type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要过滤的optional右值 / Optional rvalue to filter </td></tr>
    <tr><td class="paramname">p</td><td>要应用的谓词 / Predicate to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果谓词返回true则为optional,否则为空optional / Optional if predicate returns true, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 过滤optional右值的示例 / Example of filtering optional rvalue</span></div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(std::optional&lt;int&gt;(42), [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0;</div>
<div class="line">}); <span class="comment">// 包含42 / Contains 42</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adb40cb4be7d2e760e5cf545c558aa87f" name="adb40cb4be7d2e760e5cf545c558aa87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb40cb4be7d2e760e5cf545c558aa87f">&#9670;&#160;</a></span>filter() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::filter </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; T &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>基于谓词过滤optional右值 / Filters an optional rvalue based on a predicate </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">P</td><td>谓词类型 / Predicate type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要过滤的optional右值 / Optional rvalue to filter </td></tr>
    <tr><td class="paramname">p</td><td>要应用的谓词 / Predicate to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果谓词返回true则为optional,否则为空optional / Optional if predicate returns true, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 过滤optional右值的示例 / Example of filtering optional rvalue</span></div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4e0c6694011c494298113d01b2b3e9de">filter</a>(std::optional&lt;int&gt;(42), [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x % 2 == 0;</div>
<div class="line">}); <span class="comment">// 包含42 / Contains 42</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="abea94163fa9d90b3c3a81a6f82fd31cd" name="abea94163fa9d90b3c3a81a6f82fd31cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abea94163fa9d90b3c3a81a6f82fd31cd">&#9670;&#160;</a></span>flatMap() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::flatMap </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::invoke_result_t&lt; F, const T &amp; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional值上平面映射函数 / Flat maps a function over an optional value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>返回optional的函数类型 / Function type returning optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要平面映射的optional / Optional to flat map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则为f的结果,否则为空optional / Result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional上平面映射的示例 / Example of flat mapping over optional</span></div>
<div class="line">std::optional&lt;int&gt; opt(5);</div>
<div class="line"><span class="keyword">auto</span> maybe_double = [](<span class="keywordtype">int</span> x) -&gt; std::optional&lt;int&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> x &lt; 10 ? std::optional(x * 2) : <a class="code hl_namespace" href="namespacestd.html">std</a>::nullopt;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#abea94163fa9d90b3c3a81a6f82fd31cd">flatMap</a>(opt, maybe_double); <span class="comment">// 包含10 / Contains 10</span></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition</b> endian.hpp:42</div></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_abea94163fa9d90b3c3a81a6f82fd31cd"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#abea94163fa9d90b3c3a81a6f82fd31cd">toolbox::functional::flatMap</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto flatMap(const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;f) -&gt; std::invoke_result_t&lt; F, const T &amp; &gt;</div><div class="ttdoc">在optional值上平面映射函数 / Flat maps a function over an optional value</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:182</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a424450bf0ce67fb53903b20dee8b1765" name="a424450bf0ce67fb53903b20dee8b1765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424450bf0ce67fb53903b20dee8b1765">&#9670;&#160;</a></span>flatMap() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::flatMap </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::invoke_result_t&lt; F, const T &amp; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional值上平面映射函数 / Flat maps a function over an optional value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>返回optional的函数类型 / Function type returning optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要平面映射的optional / Optional to flat map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则为f的结果,否则为空optional / Result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional上平面映射的示例 / Example of flat mapping over optional</span></div>
<div class="line">std::optional&lt;int&gt; opt(5);</div>
<div class="line"><span class="keyword">auto</span> maybe_double = [](<span class="keywordtype">int</span> x) -&gt; std::optional&lt;int&gt; {</div>
<div class="line">  <span class="keywordflow">return</span> x &lt; 10 ? std::optional(x * 2) : <a class="code hl_namespace" href="namespacestd.html">std</a>::nullopt;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#abea94163fa9d90b3c3a81a6f82fd31cd">flatMap</a>(opt, maybe_double); <span class="comment">// 包含10 / Contains 10</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8866f4d6dc615d3c2b237adea3cf0810" name="a8866f4d6dc615d3c2b237adea3cf0810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8866f4d6dc615d3c2b237adea3cf0810">&#9670;&#160;</a></span>flatMap() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::flatMap </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::invoke_result_t&lt; F, T &amp;&amp; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional右值上平面映射函数 / Flat maps a function over an optional rvalue </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>返回optional的函数类型 / Function type returning optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要平面映射的optional右值 / Optional rvalue to flat map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则为f的结果,否则为空optional / Result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional右值上平面映射的示例 / Example of flat mapping over optional</span></div>
<div class="line">rvalue <span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#abea94163fa9d90b3c3a81a6f82fd31cd">flatMap</a>(std::optional&lt;int&gt;(5),</div>
<div class="line">                     [](<span class="keywordtype">int</span> x) -&gt; std::optional&lt;int&gt; {</div>
<div class="line">                       <span class="keywordflow">return</span> x &lt; 10 ? std::optional(x * 2) : <a class="code hl_namespace" href="namespacestd.html">std</a>::nullopt;</div>
<div class="line">                     }); <span class="comment">// 包含10 / Contains 10</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a20f50536887abe0448cb0484c4ec3abb" name="a20f50536887abe0448cb0484c4ec3abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f50536887abe0448cb0484c4ec3abb">&#9670;&#160;</a></span>flatMap() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::flatMap </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::invoke_result_t&lt; F, T &amp;&amp; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional右值上平面映射函数 / Flat maps a function over an optional rvalue </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>返回optional的函数类型 / Function type returning optional </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要平面映射的optional右值 / Optional rvalue to flat map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则为f的结果,否则为空optional / Result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional右值上平面映射的示例 / Example of flat mapping over optional</span></div>
<div class="line">rvalue <span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#abea94163fa9d90b3c3a81a6f82fd31cd">flatMap</a>(std::optional&lt;int&gt;(5),</div>
<div class="line">                     [](<span class="keywordtype">int</span> x) -&gt; std::optional&lt;int&gt; {</div>
<div class="line">                       <span class="keywordflow">return</span> x &lt; 10 ? std::optional(x * 2) : <a class="code hl_namespace" href="namespacestd.html">std</a>::nullopt;</div>
<div class="line">                     }); <span class="comment">// 包含10 / Contains 10</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7dfa628faf0096a6a08a7a528161f86b" name="a7dfa628faf0096a6a08a7a528161f86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfa628faf0096a6a08a7a528161f86b">&#9670;&#160;</a></span>map() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::vector&lt; std::invoke_result_t&lt; Func, typename Container::const_reference &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对容器中的每个元素应用函数并返回结果向量 / Apply a function to each element in a container and return results in a vector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">Func</td><td>要应用到元素的函数类型 / Function type to apply to elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器 / Input container </td></tr>
    <tr><td class="paramname">f</td><td>要应用到每个元素的函数 / Function to apply to each element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含对每个元素应用f的结果的向量 / Vector containing results of applying f to each element</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 基本用法 / Basic usage</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> squares = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(nums, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; });</div>
<div class="line"><span class="comment">// 返回 {1, 4, 9} / Returns {1, 4, 9}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 字符串长度映射 / String length mapping</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bb&quot;</span>, <span class="stringliteral">&quot;ccc&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> lengths = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(strs, [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s) { <span class="keywordflow">return</span> s.length(); });</div>
<div class="line"><span class="comment">// 返回 {1, 2, 3} / Returns {1, 2, 3}</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_ab987da3dae28f15d0476a73bcb249c31"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">toolbox::functional::map</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto map(const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;f) -&gt; std::optional&lt; std::invoke_result_t&lt; F, const T &amp; &gt; &gt;</div><div class="ttdoc">在optional值上映射函数 / Maps a function over an optional value</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:153</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="af8acf31a60d51288362956265e3addf2" name="af8acf31a60d51288362956265e3addf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8acf31a60d51288362956265e3addf2">&#9670;&#160;</a></span>map() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::vector&lt; std::invoke_result_t&lt; Func, typename Container::const_reference &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对容器中的每个元素应用函数并返回结果向量 / Apply a function to each element in a container and return results in a vector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">Func</td><td>要应用到元素的函数类型 / Function type to apply to elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器 / Input container </td></tr>
    <tr><td class="paramname">f</td><td>要应用到每个元素的函数 / Function to apply to each element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含对每个元素应用f的结果的向量 / Vector containing results of applying f to each element</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 基本用法 / Basic usage</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3};</div>
<div class="line"><span class="keyword">auto</span> squares = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(nums, [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * x; });</div>
<div class="line"><span class="comment">// 返回 {1, 4, 9} / Returns {1, 4, 9}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 字符串长度映射 / String length mapping</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;bb&quot;</span>, <span class="stringliteral">&quot;ccc&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> lengths = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(strs, [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; s) { <span class="keywordflow">return</span> s.length(); });</div>
<div class="line"><span class="comment">// 返回 {1, 2, 3} / Returns {1, 2, 3}</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab987da3dae28f15d0476a73bcb249c31" name="ab987da3dae28f15d0476a73bcb249c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab987da3dae28f15d0476a73bcb249c31">&#9670;&#160;</a></span>map() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; std::invoke_result_t&lt; F, const T &amp; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional值上映射函数 / Maps a function over an optional value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>函数类型 / Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要映射的optional / Optional to map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则包含f的结果的optional,否则为空optional / Optional containing result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional上映射的示例 / Example of mapping over optional</span></div>
<div class="line">std::optional&lt;int&gt; opt(5);</div>
<div class="line"><span class="keyword">auto</span> times_two = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; };</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(opt, times_two); <span class="comment">// 包含10 / Contains 10</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac473d11cdff7b5498e4d4562534d6cd8" name="ac473d11cdff7b5498e4d4562534d6cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac473d11cdff7b5498e4d4562534d6cd8">&#9670;&#160;</a></span>map() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; std::invoke_result_t&lt; F, const T &amp; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional值上映射函数 / Maps a function over an optional value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>函数类型 / Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要映射的optional / Optional to map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则包含f的结果的optional,否则为空optional / Optional containing result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional上映射的示例 / Example of mapping over optional</span></div>
<div class="line">std::optional&lt;int&gt; opt(5);</div>
<div class="line"><span class="keyword">auto</span> times_two = [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; };</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(opt, times_two); <span class="comment">// 包含10 / Contains 10</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a470b06977505a96a3ee4ca05e6ca9907" name="a470b06977505a96a3ee4ca05e6ca9907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a470b06977505a96a3ee4ca05e6ca9907">&#9670;&#160;</a></span>map() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultVariant , typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">const std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ResultVariant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对variant中保存的值应用函数并在新variant中返回结果 / Apply a function to the value held by a variant and return result in a new variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultVariant</td><td>要返回的目标variant类型 / The target variant type to return </td></tr>
    <tr><td class="paramname">Ts</td><td>输入variant中的类型 / Types in input variant </td></tr>
    <tr><td class="paramname">F</td><td>要应用的函数类型 / Function type to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>输入variant / Input variant </td></tr>
    <tr><td class="paramname">f</td><td>要应用到variant值的函数 / Function to apply to variant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含f的结果的ResultVariant / ResultVariant containing f's result </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_variant_access</td><td>如果var是valueless_by_exception / if var is valueless_by_exception </td></tr>
    <tr><td class="paramname">f抛出的任何异常</td><td>/ Any exception thrown by f </td></tr>
    <tr><td class="paramname">std::bad_variant_access</td><td>如果f的结果不能构造任何ResultVariant类型 / if f's result cannot construct any ResultVariant type</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// 在variant上映射的示例 / Example of mapping over variant</span></div>
<div class="line">std::variant&lt;int, std::string&gt; v = 42;</div>
<div class="line"><span class="keyword">auto</span> result = map&lt;std::variant&lt;double, size_t&gt;&gt;(v,</div>
<div class="line">  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) -&gt; std::variant&lt;double, size_t&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;std::decay_t&lt;<span class="keyword">decltype</span>(x)&gt;, <span class="keywordtype">int</span>&gt;) {</div>
<div class="line">      <span class="keywordflow">return</span> x * 1.5; <span class="comment">// int -&gt; double</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> x.length(); <span class="comment">// string -&gt; size_t</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">); <span class="comment">// 返回包含63.0的variant / Returns variant containing 63.0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a65a3a49ee3d8b5063e93e806d350db95" name="a65a3a49ee3d8b5063e93e806d350db95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a3a49ee3d8b5063e93e806d350db95">&#9670;&#160;</a></span>map() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultVariant , typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">const std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ResultVariant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对variant中保存的值应用函数并在新variant中返回结果 / Apply a function to the value held by a variant and return result in a new variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultVariant</td><td>要返回的目标variant类型 / The target variant type to return </td></tr>
    <tr><td class="paramname">Ts</td><td>输入variant中的类型 / Types in input variant </td></tr>
    <tr><td class="paramname">F</td><td>要应用的函数类型 / Function type to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>输入variant / Input variant </td></tr>
    <tr><td class="paramname">f</td><td>要应用到variant值的函数 / Function to apply to variant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含f的结果的ResultVariant / ResultVariant containing f's result </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_variant_access</td><td>如果var是valueless_by_exception / if var is valueless_by_exception </td></tr>
    <tr><td class="paramname">f抛出的任何异常</td><td>/ Any exception thrown by f </td></tr>
    <tr><td class="paramname">std::bad_variant_access</td><td>如果f的结果不能构造任何ResultVariant类型 / if f's result cannot construct any ResultVariant type</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// 在variant上映射的示例 / Example of mapping over variant</span></div>
<div class="line">std::variant&lt;int, std::string&gt; v = 42;</div>
<div class="line"><span class="keyword">auto</span> result = map&lt;std::variant&lt;double, size_t&gt;&gt;(v,</div>
<div class="line">  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; x) -&gt; std::variant&lt;double, size_t&gt; {</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;std::decay_t&lt;<span class="keyword">decltype</span>(x)&gt;, <span class="keywordtype">int</span>&gt;) {</div>
<div class="line">      <span class="keywordflow">return</span> x * 1.5; <span class="comment">// int -&gt; double</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> x.length(); <span class="comment">// string -&gt; size_t</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">); <span class="comment">// 返回包含63.0的variant / Returns variant containing 63.0</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae876add04e6a887f8b62c69d6d6c798b" name="ae876add04e6a887f8b62c69d6d6c798b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae876add04e6a887f8b62c69d6d6c798b">&#9670;&#160;</a></span>map() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; std::invoke_result_t&lt; F, T &amp;&amp; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional右值上映射函数 / Maps a function over an optional rvalue </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>函数类型 / Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要映射的optional右值 / Optional rvalue to map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则包含f的结果的optional,否则为空optional / Optional containing result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional右值上映射的示例 / Example of mapping over optional rvalue</span></div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(std::optional&lt;int&gt;(5), [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; }); <span class="comment">//</span></div>
<div class="line">包含10 / Contains 10</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af8327d7a971ca42627faa5b66ad81012" name="af8327d7a971ca42627faa5b66ad81012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8327d7a971ca42627faa5b66ad81012">&#9670;&#160;</a></span>map() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">std::optional&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::optional&lt; std::invoke_result_t&lt; F, T &amp;&amp; &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>在optional右值上映射函数 / Maps a function over an optional rvalue </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>函数类型 / Function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要映射的optional右值 / Optional rvalue to map over </td></tr>
    <tr><td class="paramname">f</td><td>要应用的函数 / Function to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如果opt有值则包含f的结果的optional,否则为空optional / Optional containing result of f if opt has value, empty optional otherwise</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在optional右值上映射的示例 / Example of mapping over optional rvalue</span></div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a>(std::optional&lt;int&gt;(5), [](<span class="keywordtype">int</span> x) { <span class="keywordflow">return</span> x * 2; }); <span class="comment">//</span></div>
<div class="line">包含10 / Contains 10</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad0df97865b75c205b0ae131de8b81688" name="ad0df97865b75c205b0ae131de8b81688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0df97865b75c205b0ae131de8b81688">&#9670;&#160;</a></span>map() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultVariant , typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ResultVariant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对右值variant中保存的值应用函数 / Apply a function to the value held by an rvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultVariant</td><td>要返回的目标variant类型 / The target variant type to return </td></tr>
    <tr><td class="paramname">Ts</td><td>输入variant中的类型 / Types in input variant </td></tr>
    <tr><td class="paramname">F</td><td>要应用的函数类型 / Function type to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>输入variant / Input variant </td></tr>
    <tr><td class="paramname">f</td><td>要应用到variant值的函数 / Function to apply to variant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含f的结果的ResultVariant / ResultVariant containing f's result</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在右值variant上映射的示例 / Example of mapping over rvalue variant</span></div>
<div class="line"><span class="keyword">auto</span> result = map&lt;std::variant&lt;std::string&gt;&gt;(</div>
<div class="line">  std::variant&lt;int, std::string&gt;(42),</div>
<div class="line">  [](<span class="keyword">auto</span>&amp;&amp; x) { <span class="keywordflow">return</span> std::to_string(x); }</div>
<div class="line">); <span class="comment">// 返回包含&quot;42&quot;的variant / Returns variant containing &quot;42&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6ec605443bd2b2ee732a30baf2427805" name="a6ec605443bd2b2ee732a30baf2427805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ec605443bd2b2ee732a30baf2427805">&#9670;&#160;</a></span>map() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultVariant , typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ResultVariant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对右值variant中保存的值应用函数 / Apply a function to the value held by an rvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultVariant</td><td>要返回的目标variant类型 / The target variant type to return </td></tr>
    <tr><td class="paramname">Ts</td><td>输入variant中的类型 / Types in input variant </td></tr>
    <tr><td class="paramname">F</td><td>要应用的函数类型 / Function type to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>输入variant / Input variant </td></tr>
    <tr><td class="paramname">f</td><td>要应用到variant值的函数 / Function to apply to variant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含f的结果的ResultVariant / ResultVariant containing f's result</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在右值variant上映射的示例 / Example of mapping over rvalue variant</span></div>
<div class="line"><span class="keyword">auto</span> result = map&lt;std::variant&lt;std::string&gt;&gt;(</div>
<div class="line">  std::variant&lt;int, std::string&gt;(42),</div>
<div class="line">  [](<span class="keyword">auto</span>&amp;&amp; x) { <span class="keywordflow">return</span> std::to_string(x); }</div>
<div class="line">); <span class="comment">// 返回包含&quot;42&quot;的variant / Returns variant containing &quot;42&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a7e06cdbbc5ffdb751d6ec6b7b42dc2f3" name="a7e06cdbbc5ffdb751d6ec6b7b42dc2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e06cdbbc5ffdb751d6ec6b7b42dc2f3">&#9670;&#160;</a></span>map() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultVariant , typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ResultVariant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对非const左值variant中保存的值应用函数 / Apply a function to the value held by a non-const lvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultVariant</td><td>要返回的目标variant类型 / The target variant type to return </td></tr>
    <tr><td class="paramname">Ts</td><td>输入variant中的类型 / Types in input variant </td></tr>
    <tr><td class="paramname">F</td><td>要应用的函数类型 / Function type to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>输入variant / Input variant </td></tr>
    <tr><td class="paramname">f</td><td>要应用到variant值的函数 / Function to apply to variant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含f的结果的ResultVariant / ResultVariant containing f's result</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在左值variant上映射的示例 / Example of mapping over lvalue variant</span></div>
<div class="line">std::variant&lt;int, std::string&gt; v = 42;</div>
<div class="line"><span class="keyword">auto</span> result = map&lt;std::variant&lt;double&gt;&gt;(v,</div>
<div class="line">  [](<span class="keywordtype">int</span>&amp; x) { x *= 2; <span class="keywordflow">return</span> x * 1.5; }</div>
<div class="line">); <span class="comment">// 修改v并返回包含126.0的variant / Modifies v and returns variant</span></div>
<div class="line">containing 126.0</div>
</div><!-- fragment --> 
</div>
</div>
<a id="abe0946f6ce3008057d1e5a6c5ee9b120" name="abe0946f6ce3008057d1e5a6c5ee9b120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe0946f6ce3008057d1e5a6c5ee9b120">&#9670;&#160;</a></span>map() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultVariant , typename... Ts, typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::map </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ResultVariant</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对非const左值variant中保存的值应用函数 / Apply a function to the value held by a non-const lvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ResultVariant</td><td>要返回的目标variant类型 / The target variant type to return </td></tr>
    <tr><td class="paramname">Ts</td><td>输入variant中的类型 / Types in input variant </td></tr>
    <tr><td class="paramname">F</td><td>要应用的函数类型 / Function type to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>输入variant / Input variant </td></tr>
    <tr><td class="paramname">f</td><td>要应用到variant值的函数 / Function to apply to variant value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含f的结果的ResultVariant / ResultVariant containing f's result</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 在左值variant上映射的示例 / Example of mapping over lvalue variant</span></div>
<div class="line">std::variant&lt;int, std::string&gt; v = 42;</div>
<div class="line"><span class="keyword">auto</span> result = map&lt;std::variant&lt;double&gt;&gt;(v,</div>
<div class="line">  [](<span class="keywordtype">int</span>&amp; x) { x *= 2; <span class="keywordflow">return</span> x * 1.5; }</div>
<div class="line">); <span class="comment">// 修改v并返回包含126.0的variant / Modifies v and returns variant</span></div>
<div class="line">containing 126.0</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a76f1f065e91d8b2571f14cc350983a02" name="a76f1f065e91d8b2571f14cc350983a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f1f065e91d8b2571f14cc350983a02">&#9670;&#160;</a></span>match() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::match </td>
          <td>(</td>
          <td class="paramtype">const std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>visitors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>使用访问器函数对variant进行模式匹配 / Pattern matches on a variant using visitor functions </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>variant中的类型 / Types in variant </td></tr>
    <tr><td class="paramname">Fs</td><td>访问器函数类型 / Visitor function types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>要匹配的variant / Variant to match on </td></tr>
    <tr><td class="paramname">visitors</td><td>每个类型的访问器函数 / Visitor functions for each type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>匹配的访问器的结果 / Result of matched visitor</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// variant模式匹配的示例 / Example of pattern matching on variant</span></div>
<div class="line">std::variant&lt;int, std::string&gt; v = 42;</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a>(v,</div>
<div class="line">  [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i * 2; },</div>
<div class="line">  [](<span class="keyword">const</span> std::string&amp; s) { <span class="keywordflow">return</span> s.length(); }</div>
<div class="line">); <span class="comment">// 返回84 / Returns 84</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a76f1f065e91d8b2571f14cc350983a02"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">toolbox::functional::match</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto match(const std::variant&lt; Ts... &gt; &amp;var, Fs &amp;&amp;... visitors) -&gt; decltype(auto)</div><div class="ttdoc">使用访问器函数对variant进行模式匹配 / Pattern matches on a variant using visitor functions</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:290</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adfc20d2de6408ff5e8bda0b7174c2bf9" name="adfc20d2de6408ff5e8bda0b7174c2bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfc20d2de6408ff5e8bda0b7174c2bf9">&#9670;&#160;</a></span>match() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::match </td>
          <td>(</td>
          <td class="paramtype">const std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>visitors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>使用访问器函数对variant进行模式匹配 / Pattern matches on a variant using visitor functions </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>variant中的类型 / Types in variant </td></tr>
    <tr><td class="paramname">Fs</td><td>访问器函数类型 / Visitor function types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>要匹配的variant / Variant to match on </td></tr>
    <tr><td class="paramname">visitors</td><td>每个类型的访问器函数 / Visitor functions for each type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>匹配的访问器的结果 / Result of matched visitor</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// variant模式匹配的示例 / Example of pattern matching on variant</span></div>
<div class="line">std::variant&lt;int, std::string&gt; v = 42;</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a>(v,</div>
<div class="line">  [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i * 2; },</div>
<div class="line">  [](<span class="keyword">const</span> std::string&amp; s) { <span class="keywordflow">return</span> s.length(); }</div>
<div class="line">); <span class="comment">// 返回84 / Returns 84</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a09ce89a295a09678c2d0aa2dd9903ceb" name="a09ce89a295a09678c2d0aa2dd9903ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ce89a295a09678c2d0aa2dd9903ceb">&#9670;&#160;</a></span>match() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::match </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>visitors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对右值variant使用访问器函数进行匹配 / Match variant with visitor functions for rvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>variant中的类型 / Types in variant </td></tr>
    <tr><td class="paramname">Fs</td><td>访问器函数类型 / Visitor function types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>要匹配的variant / Variant to match on </td></tr>
    <tr><td class="paramname">visitors</td><td>每个类型的访问器函数 / Visitor functions for each type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>匹配的访问器的结果 / Result of matched visitor</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 对右值variant进行模式匹配的示例 / Example of pattern matching on rvalue</span></div>
<div class="line">variant <span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a>(std::variant&lt;int, std::string&gt;(42),</div>
<div class="line">  [](<span class="keywordtype">int</span>&amp;&amp; i) { <span class="keywordflow">return</span> i * 2; },</div>
<div class="line">  [](std::string&amp;&amp; s) { <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;!&quot;</span>; }</div>
<div class="line">); <span class="comment">// 返回84 / Returns 84</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a48db12c30c97eddfdbe5bb80179b94f4" name="a48db12c30c97eddfdbe5bb80179b94f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db12c30c97eddfdbe5bb80179b94f4">&#9670;&#160;</a></span>match() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::match </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>visitors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对右值variant使用访问器函数进行匹配 / Match variant with visitor functions for rvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>variant中的类型 / Types in variant </td></tr>
    <tr><td class="paramname">Fs</td><td>访问器函数类型 / Visitor function types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>要匹配的variant / Variant to match on </td></tr>
    <tr><td class="paramname">visitors</td><td>每个类型的访问器函数 / Visitor functions for each type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>匹配的访问器的结果 / Result of matched visitor</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 对右值variant进行模式匹配的示例 / Example of pattern matching on rvalue</span></div>
<div class="line">variant <span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a>(std::variant&lt;int, std::string&gt;(42),</div>
<div class="line">  [](<span class="keywordtype">int</span>&amp;&amp; i) { <span class="keywordflow">return</span> i * 2; },</div>
<div class="line">  [](std::string&amp;&amp; s) { <span class="keywordflow">return</span> s + <span class="stringliteral">&quot;!&quot;</span>; }</div>
<div class="line">); <span class="comment">// 返回84 / Returns 84</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a1893e027e95dd95cee03d2c216de4205" name="a1893e027e95dd95cee03d2c216de4205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1893e027e95dd95cee03d2c216de4205">&#9670;&#160;</a></span>match() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::match </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>visitors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对非const左值variant使用访问器函数进行匹配 / Match variant with visitor functions for non-const lvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>variant中的类型 / Types in variant </td></tr>
    <tr><td class="paramname">Fs</td><td>访问器函数类型 / Visitor function types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>要匹配的variant / Variant to match on </td></tr>
    <tr><td class="paramname">visitors</td><td>每个类型的访问器函数 / Visitor functions for each type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>匹配的访问器的结果 / Result of matched visitor</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 对左值variant进行模式匹配的示例 / Example of pattern matching on lvalue</span></div>
<div class="line">variant std::variant&lt;int, std::string&gt; v = 42; <span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a>(v,</div>
<div class="line">  [](<span class="keywordtype">int</span>&amp; i) { i *= 2; <span class="keywordflow">return</span> i; },</div>
<div class="line">  [](std::string&amp; s) { s += <span class="stringliteral">&quot;!&quot;</span>; <span class="keywordflow">return</span> s.length(); }</div>
<div class="line">); <span class="comment">// 修改v并返回84 / Modifies v and returns 84</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a31150fb88996d76590ccc35593c7b70d" name="a31150fb88996d76590ccc35593c7b70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31150fb88996d76590ccc35593c7b70d">&#9670;&#160;</a></span>match() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename... Fs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::match </td>
          <td>(</td>
          <td class="paramtype">std::variant&lt; Ts... &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>visitors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  decltype(auto)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>对非const左值variant使用访问器函数进行匹配 / Match variant with visitor functions for non-const lvalue variant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>variant中的类型 / Types in variant </td></tr>
    <tr><td class="paramname">Fs</td><td>访问器函数类型 / Visitor function types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>要匹配的variant / Variant to match on </td></tr>
    <tr><td class="paramname">visitors</td><td>每个类型的访问器函数 / Visitor functions for each type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>匹配的访问器的结果 / Result of matched visitor</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 对左值variant进行模式匹配的示例 / Example of pattern matching on lvalue</span></div>
<div class="line">variant std::variant&lt;int, std::string&gt; v = 42; <span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a76f1f065e91d8b2571f14cc350983a02">match</a>(v,</div>
<div class="line">  [](<span class="keywordtype">int</span>&amp; i) { i *= 2; <span class="keywordflow">return</span> i; },</div>
<div class="line">  [](std::string&amp; s) { s += <span class="stringliteral">&quot;!&quot;</span>; <span class="keywordflow">return</span> s.length(); }</div>
<div class="line">); <span class="comment">// 修改v并返回84 / Modifies v and returns 84</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8c3f8127f603901d466318d6aaff381f" name="a8c3f8127f603901d466318d6aaff381f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3f8127f603901d466318d6aaff381f">&#9670;&#160;</a></span>memoize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::memoize </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建带显式签名的记忆化函数 / Create a memoized function with explicit signature </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Signature</td><td>函数签名类型 / Function signature type </td></tr>
    <tr><td class="paramname">Func</td><td>函数对象类型 / Function object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>要记忆化的函数 / Function to memoize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MemoizedFunction对象 / MemoizedFunction object</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 带显式签名的记忆化函数 / Memoized function with explicit signature</span></div>
<div class="line"><span class="keyword">auto</span> memoized_add = memoize&lt;int(int,int)&gt;([](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> result1 = memoized_add(2, 3); <span class="comment">// 计算并缓存 / Computes and caches</span></div>
<div class="line"><span class="keywordtype">int</span> result2 = memoized_add(2, 3); <span class="comment">// 返回缓存结果 / Returns cached result</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a67ae7d48b6cf42eb8a27dbf3a970167b" name="a67ae7d48b6cf42eb8a27dbf3a970167b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ae7d48b6cf42eb8a27dbf3a970167b">&#9670;&#160;</a></span>memoize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature , typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::memoize </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建带显式签名的记忆化函数 / Create a memoized function with explicit signature </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Signature</td><td>函数签名类型 / Function signature type </td></tr>
    <tr><td class="paramname">Func</td><td>函数对象类型 / Function object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>要记忆化的函数 / Function to memoize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>MemoizedFunction对象 / MemoizedFunction object</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 带显式签名的记忆化函数 / Memoized function with explicit signature</span></div>
<div class="line"><span class="keyword">auto</span> memoized_add = memoize&lt;int(int,int)&gt;([](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">  <span class="keywordflow">return</span> a + b;</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> result1 = memoized_add(2, 3); <span class="comment">// 计算并缓存 / Computes and caches</span></div>
<div class="line"><span class="keywordtype">int</span> result2 = memoized_add(2, 3); <span class="comment">// 返回缓存结果 / Returns cached result</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae451cc75b6a39fd16d3c1c680988706e" name="ae451cc75b6a39fd16d3c1c680988706e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae451cc75b6a39fd16d3c1c680988706e">&#9670;&#160;</a></span>memoize_explicit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::memoize_explicit </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt;  std::function&lt; R(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建带显式返回和参数类型的记忆化函数 / Create a memoized function with explicit return and argument types </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>返回类型 / Return type </td></tr>
    <tr><td class="paramname">Args</td><td>参数类型 / Argument types </td></tr>
    <tr><td class="paramname">Func</td><td>函数对象类型 / Function object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>要记忆化的函数 / Function to memoize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>带记忆化的std::function / std::function with memoization</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 记忆化斐波那契函数 / Memoized fibonacci function</span></div>
<div class="line"><span class="keyword">auto</span> fib = memoize_explicit&lt;int, int&gt;([&amp;](<span class="keywordtype">int</span> n) {</div>
<div class="line">  <span class="keywordflow">if</span> (n &lt;= 1) <span class="keywordflow">return</span> n;</div>
<div class="line">  <span class="keywordflow">return</span> fib(n-1) + fib(n-2);</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> result = fib(10); <span class="comment">// 高效计算斐波那契数 / Efficiently computes fibonacci</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>使用共享状态的线程安全实现 / Thread-safe implementation using shared state </dd>
<dd>
参数经过decay后必须能形成有效的映射键 / Arguments must form valid map key after decay </dd>
<dd>
返回类型必须可复制 / Return type must be copyable </dd></dl>

</div>
</div>
<a id="af4ca279b16162dbbf7042fc2681bdba7" name="af4ca279b16162dbbf7042fc2681bdba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ca279b16162dbbf7042fc2681bdba7">&#9670;&#160;</a></span>memoize_explicit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... Args, typename Func &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::memoize_explicit </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt;  std::function&lt; R(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>创建带显式返回和参数类型的记忆化函数 / Create a memoized function with explicit return and argument types </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>返回类型 / Return type </td></tr>
    <tr><td class="paramname">Args</td><td>参数类型 / Argument types </td></tr>
    <tr><td class="paramname">Func</td><td>函数对象类型 / Function object type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>要记忆化的函数 / Function to memoize </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>带记忆化的std::function / std::function with memoization</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 记忆化斐波那契函数 / Memoized fibonacci function</span></div>
<div class="line"><span class="keyword">auto</span> fib = memoize_explicit&lt;int, int&gt;([&amp;](<span class="keywordtype">int</span> n) {</div>
<div class="line">  <span class="keywordflow">if</span> (n &lt;= 1) <span class="keywordflow">return</span> n;</div>
<div class="line">  <span class="keywordflow">return</span> fib(n-1) + fib(n-2);</div>
<div class="line">});</div>
<div class="line"><span class="keywordtype">int</span> result = fib(10); <span class="comment">// 高效计算斐波那契数 / Efficiently computes fibonacci</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>使用共享状态的线程安全实现 / Thread-safe implementation using shared state </dd>
<dd>
参数经过decay后必须能形成有效的映射键 / Arguments must form valid map key after decay </dd>
<dd>
返回类型必须可复制 / Return type must be copyable </dd></dl>

</div>
</div>
<a id="a50e389bf7d4e1f5788548cd2784de28f" name="a50e389bf7d4e1f5788548cd2784de28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e389bf7d4e1f5788548cd2784de28f">&#9670;&#160;</a></span>orElse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::orElse </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回包含的值或默认值 / Returns the contained value or a default </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">U</td><td>默认值类型 / Type of default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要获取值的optional / Optional to get value from </td></tr>
    <tr><td class="paramname">default_value</td><td>如果optional为空时返回的值 / Value to return if optional is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含的值或默认值 / Contained value or default</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 提供默认值的示例 / Example of providing default value</span></div>
<div class="line">std::optional&lt;int&gt; opt;</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a50e389bf7d4e1f5788548cd2784de28f">orElse</a>(opt, 42); <span class="comment">// 返回42 / Returns 42</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a50e389bf7d4e1f5788548cd2784de28f"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a50e389bf7d4e1f5788548cd2784de28f">toolbox::functional::orElse</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto orElse(const std::optional&lt; T &gt; &amp;opt, U &amp;&amp;default_value) -&gt; T</div><div class="ttdoc">返回包含的值或默认值 / Returns the contained value or a default</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:214</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad0b4c848e551d917eebb0bebfa50fc66" name="ad0b4c848e551d917eebb0bebfa50fc66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b4c848e551d917eebb0bebfa50fc66">&#9670;&#160;</a></span>orElse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::orElse </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回包含的值或默认值 / Returns the contained value or a default </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">U</td><td>默认值类型 / Type of default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要获取值的optional / Optional to get value from </td></tr>
    <tr><td class="paramname">default_value</td><td>如果optional为空时返回的值 / Value to return if optional is empty </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含的值或默认值 / Contained value or default</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 提供默认值的示例 / Example of providing default value</span></div>
<div class="line">std::optional&lt;int&gt; opt;</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a50e389bf7d4e1f5788548cd2784de28f">orElse</a>(opt, 42); <span class="comment">// 返回42 / Returns 42</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4a7a4acdd8ba7485698f9ea3e64920e9" name="a4a7a4acdd8ba7485698f9ea3e64920e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a7a4acdd8ba7485698f9ea3e64920e9">&#9670;&#160;</a></span>orElseGet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::orElseGet </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回包含的值或调用函数获取默认值 / Returns the contained value or calls function for default </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>返回默认值的函数类型 / Function type returning default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要获取值的optional / Optional to get value from </td></tr>
    <tr><td class="paramname">default_func</td><td>用于获取默认值的函数 / Function to call for default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含的值或default_func的结果 / Contained value or result of default_func</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 通过函数提供默认值的示例 / Example of providing default via function</span></div>
<div class="line">std::optional&lt;int&gt; opt;</div>
<div class="line"><span class="keyword">auto</span> get_default = []() { <span class="keywordflow">return</span> 42; };</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4a7a4acdd8ba7485698f9ea3e64920e9">orElseGet</a>(opt, get_default); <span class="comment">// 返回42 / Returns 42</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a4a7a4acdd8ba7485698f9ea3e64920e9"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a4a7a4acdd8ba7485698f9ea3e64920e9">toolbox::functional::orElseGet</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto orElseGet(const std::optional&lt; T &gt; &amp;opt, F &amp;&amp;default_func) -&gt; T</div><div class="ttdoc">返回包含的值或调用函数获取默认值 / Returns the contained value or calls function for default</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:224</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae1baad6982df3cde2d03724aa870e274" name="ae1baad6982df3cde2d03724aa870e274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1baad6982df3cde2d03724aa870e274">&#9670;&#160;</a></span>orElseGet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::orElseGet </td>
          <td>(</td>
          <td class="paramtype">const std::optional&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>opt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>返回包含的值或调用函数获取默认值 / Returns the contained value or calls function for default </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>optional中包含的类型 / Type contained in optional </td></tr>
    <tr><td class="paramname">F</td><td>返回默认值的函数类型 / Function type returning default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>要获取值的optional / Optional to get value from </td></tr>
    <tr><td class="paramname">default_func</td><td>用于获取默认值的函数 / Function to call for default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含的值或default_func的结果 / Contained value or result of default_func</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 通过函数提供默认值的示例 / Example of providing default via function</span></div>
<div class="line">std::optional&lt;int&gt; opt;</div>
<div class="line"><span class="keyword">auto</span> get_default = []() { <span class="keywordflow">return</span> 42; };</div>
<div class="line"><span class="keywordtype">int</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4a7a4acdd8ba7485698f9ea3e64920e9">orElseGet</a>(opt, get_default); <span class="comment">// 返回42 / Returns 42</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a066d6a37ea371a922c192f5502bb1a26" name="a066d6a37ea371a922c192f5502bb1a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a066d6a37ea371a922c192f5502bb1a26">&#9670;&#160;</a></span>reduce() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::reduce </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  typename Container::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>使用二元操作归约非空容器元素 / Reduce non-empty container elements using a binary operation </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">BinaryOp</td><td>二元操作函数类型 / Binary operation function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器(必须非空) / Input container (must be non-empty) </td></tr>
    <tr><td class="paramname">op</td><td>组合元素的二元操作 / Binary operation to combine elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>归约的结果 / Result of reduction </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>如果输入容器为空 / if input container is empty</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// 求和 / Sum numbers</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3, 4};</div>
<div class="line"><span class="keyword">auto</span> sum = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(nums, std::plus&lt;int&gt;());</div>
<div class="line"><span class="comment">// 返回 10 / Returns 10</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 连接字符串 / Concatenate strings</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> concat = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(strs, std::plus&lt;std::string&gt;());</div>
<div class="line"><span class="comment">// 返回 &quot;abc&quot; / Returns &quot;abc&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 空容器会抛出异常 / Empty container throws</span></div>
<div class="line">std::vector&lt;int&gt; empty;</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(empty, std::plus&lt;int&gt;());</div>
<div class="line"><span class="comment">// 抛出 std::invalid_argument / throws std::invalid_argument</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a28234663d88d2ee0d2a8fc72044235e3"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">toolbox::functional::reduce</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto reduce(const Container &amp;input, T identity, BinaryOp &amp;&amp;op) -&gt; T</div><div class="ttdoc">使用带初始值的二元操作归约容器元素 / Reduce container elements using a binary operation with initial value</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:428</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a10b525e7afccde1000246e289b1469af" name="a10b525e7afccde1000246e289b1469af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b525e7afccde1000246e289b1469af">&#9670;&#160;</a></span>reduce() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::reduce </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  typename Container::value_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>使用二元操作归约非空容器元素 / Reduce non-empty container elements using a binary operation </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">BinaryOp</td><td>二元操作函数类型 / Binary operation function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器(必须非空) / Input container (must be non-empty) </td></tr>
    <tr><td class="paramname">op</td><td>组合元素的二元操作 / Binary operation to combine elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>归约的结果 / Result of reduction </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>如果输入容器为空 / if input container is empty</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// 求和 / Sum numbers</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3, 4};</div>
<div class="line"><span class="keyword">auto</span> sum = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(nums, std::plus&lt;int&gt;());</div>
<div class="line"><span class="comment">// 返回 10 / Returns 10</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 连接字符串 / Concatenate strings</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> concat = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(strs, std::plus&lt;std::string&gt;());</div>
<div class="line"><span class="comment">// 返回 &quot;abc&quot; / Returns &quot;abc&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 空容器会抛出异常 / Empty container throws</span></div>
<div class="line">std::vector&lt;int&gt; empty;</div>
<div class="line"><span class="keyword">auto</span> result = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(empty, std::plus&lt;int&gt;());</div>
<div class="line"><span class="comment">// 抛出 std::invalid_argument / throws std::invalid_argument</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a28234663d88d2ee0d2a8fc72044235e3" name="a28234663d88d2ee0d2a8fc72044235e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28234663d88d2ee0d2a8fc72044235e3">&#9670;&#160;</a></span>reduce() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::reduce </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>使用带初始值的二元操作归约容器元素 / Reduce container elements using a binary operation with initial value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">T</td><td>初始值和结果类型 / Initial value and result type </td></tr>
    <tr><td class="paramname">BinaryOp</td><td>二元操作函数类型 / Binary operation function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器 / Input container </td></tr>
    <tr><td class="paramname">identity</td><td>初始值(单位元) / Initial value (identity element) </td></tr>
    <tr><td class="paramname">op</td><td>组合元素的二元操作 / Binary operation to combine elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>归约的结果 / Result of reduction</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 求和 / Sum numbers</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3, 4};</div>
<div class="line"><span class="keyword">auto</span> sum = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(nums, 0, std::plus&lt;int&gt;());</div>
<div class="line"><span class="comment">// 返回 10 / Returns 10</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 求积 / Calculate product</span></div>
<div class="line"><span class="keyword">auto</span> product = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(nums, 1, std::multiplies&lt;int&gt;());</div>
<div class="line"><span class="comment">// 返回 24 / Returns 24</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 连接字符串 / Concatenate strings</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> concat = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(strs, std::string(), std::plus&lt;std::string&gt;());</div>
<div class="line"><span class="comment">// 返回 &quot;abc&quot; / Returns &quot;abc&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="aea3f2ee7ec3d87022b31c2f07743c4e6" name="aea3f2ee7ec3d87022b31c2f07743c4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3f2ee7ec3d87022b31c2f07743c4e6">&#9670;&#160;</a></span>reduce() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename T , typename BinaryOp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::reduce </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>identity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>使用带初始值的二元操作归约容器元素 / Reduce container elements using a binary operation with initial value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>输入容器类型,必须提供begin()和end()迭代器 / Input container type, must provide begin() and end() iterators </td></tr>
    <tr><td class="paramname">T</td><td>初始值和结果类型 / Initial value and result type </td></tr>
    <tr><td class="paramname">BinaryOp</td><td>二元操作函数类型 / Binary operation function type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>输入容器 / Input container </td></tr>
    <tr><td class="paramname">identity</td><td>初始值(单位元) / Initial value (identity element) </td></tr>
    <tr><td class="paramname">op</td><td>组合元素的二元操作 / Binary operation to combine elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>归约的结果 / Result of reduction</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 求和 / Sum numbers</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3, 4};</div>
<div class="line"><span class="keyword">auto</span> sum = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(nums, 0, std::plus&lt;int&gt;());</div>
<div class="line"><span class="comment">// 返回 10 / Returns 10</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 求积 / Calculate product</span></div>
<div class="line"><span class="keyword">auto</span> product = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(nums, 1, std::multiplies&lt;int&gt;());</div>
<div class="line"><span class="comment">// 返回 24 / Returns 24</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 连接字符串 / Concatenate strings</span></div>
<div class="line">std::list&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line"><span class="keyword">auto</span> concat = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a28234663d88d2ee0d2a8fc72044235e3">reduce</a>(strs, std::string(), std::plus&lt;std::string&gt;());</div>
<div class="line"><span class="comment">// 返回 &quot;abc&quot; / Returns &quot;abc&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac747cafdf73d872cb3827c20f3180ade" name="ac747cafdf73d872cb3827c20f3180ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac747cafdf73d872cb3827c20f3180ade">&#9670;&#160;</a></span>zip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Containers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::zip </td>
          <td>(</td>
          <td class="paramtype">const Containers &amp;...&#160;</td>
          <td class="paramname"><em>containers</em></td><td>)</td>
          <td> -&gt;  std::vector&lt; std::tuple&lt; decltype(*std::cbegin(std::declval&lt; const Containers &amp; &gt;()))... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将多个容器压缩成元组向量 / Zip multiple containers into a vector of tuples </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Containers</td><td>容器类型,必须提供size()和begin()/end() / Container types, must provide size() and begin()/end() </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containers</td><td>输入容器 / Input containers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含每个容器元素引用的元组向量 / Vector of tuples containing references to elements from each container</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 压缩不同类型的容器 / Zip containers of different types</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3};</div>
<div class="line">std::vector&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line">std::array&lt;double&gt; dbls = {1.1, 2.2, 3.3};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> zipped = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ac747cafdf73d872cb3827c20f3180ade">zip</a>(nums, strs, dbls);</div>
<div class="line"><span class="comment">// 返回元组向量 / Returns vector of tuples:</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   {1, &quot;a&quot;, 1.1},</span></div>
<div class="line"><span class="comment">//   {2, &quot;b&quot;, 2.2},</span></div>
<div class="line"><span class="comment">//   {3, &quot;c&quot;, 3.3}</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_ac747cafdf73d872cb3827c20f3180ade"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#ac747cafdf73d872cb3827c20f3180ade">toolbox::functional::zip</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto zip(const Containers &amp;... containers) -&gt; std::vector&lt; std::tuple&lt; decltype(*std::cbegin(std::declval&lt; const Containers &amp; &gt;()))... &gt; &gt;</div><div class="ttdoc">将多个容器压缩成元组向量 / Zip multiple containers into a vector of tuples</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:456</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>结果长度由最短的输入容器决定 / The length of result is determined by the shortest input container </dd></dl>

</div>
</div>
<a id="af1e716e0651b55b72aadf0561117a6bb" name="af1e716e0651b55b72aadf0561117a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e716e0651b55b72aadf0561117a6bb">&#9670;&#160;</a></span>zip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Containers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::zip </td>
          <td>(</td>
          <td class="paramtype">const Containers &amp;...&#160;</td>
          <td class="paramname"><em>containers</em></td><td>)</td>
          <td> -&gt;  std::vector&lt; std::tuple&lt; decltype(*std::cbegin(std::declval&lt; const Containers &amp; &gt;()))... &gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将多个容器压缩成元组向量 / Zip multiple containers into a vector of tuples </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Containers</td><td>容器类型,必须提供size()和begin()/end() / Container types, must provide size() and begin()/end() </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containers</td><td>输入容器 / Input containers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含每个容器元素引用的元组向量 / Vector of tuples containing references to elements from each container</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 压缩不同类型的容器 / Zip containers of different types</span></div>
<div class="line">std::vector&lt;int&gt; nums = {1, 2, 3};</div>
<div class="line">std::vector&lt;std::string&gt; strs = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line">std::array&lt;double&gt; dbls = {1.1, 2.2, 3.3};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> zipped = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ac747cafdf73d872cb3827c20f3180ade">zip</a>(nums, strs, dbls);</div>
<div class="line"><span class="comment">// 返回元组向量 / Returns vector of tuples:</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   {1, &quot;a&quot;, 1.1},</span></div>
<div class="line"><span class="comment">//   {2, &quot;b&quot;, 2.2},</span></div>
<div class="line"><span class="comment">//   {3, &quot;c&quot;, 3.3}</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>结果长度由最短的输入容器决定 / The length of result is determined by the shortest input container </dd></dl>

</div>
</div>
<a id="a4fb6acc3f4d90809e63e519440e55b7c" name="a4fb6acc3f4d90809e63e519440e55b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb6acc3f4d90809e63e519440e55b7c">&#9670;&#160;</a></span>zip_to_unordered_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerKeys , typename ContainerValues , typename Key  = typename std::decay_t&lt;ContainerKeys&gt;::value_type, typename Value  = typename std::decay_t&lt;ContainerValues&gt;::value_type, typename Hash  = std::hash&lt;Key&gt;, typename KeyEqual  = std::equal_to&lt;Key&gt;, typename Alloc  = std::allocator&lt;std::pair&lt;const Key, Value&gt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">CPP_TOOLBOX_EXPORT auto toolbox::functional::zip_to_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const ContainerKeys &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerValues &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::unordered_map&lt; Key, Value, Hash, KeyEqual, Alloc &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将两个序列压缩成无序映射 / Zip two sequences into an unordered_map </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerKeys</td><td>键容器类型 / Key container type </td></tr>
    <tr><td class="paramname">ContainerValues</td><td>值容器类型 / Value container type </td></tr>
    <tr><td class="paramname">Key</td><td>映射键类型(默认:ContainerKeys::value_type) / Map key type (default: ContainerKeys::value_type) </td></tr>
    <tr><td class="paramname">Value</td><td>映射值类型(默认:ContainerValues::value_type) / Map value type (default: ContainerValues::value_type) </td></tr>
    <tr><td class="paramname">Hash</td><td>键哈希函数类型 / Key hash function type </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>键相等比较函数类型 / Key equality comparison function type </td></tr>
    <tr><td class="paramname">Alloc</td><td>映射分配器类型 / Map allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>键容器 / Container of keys </td></tr>
    <tr><td class="paramname">values</td><td>值容器 / Container of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含键值对的无序映射 / Unordered map containing key-value pairs</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 基本用法 / Basic usage</span></div>
<div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line">std::vector&lt;int&gt; values = {1, 2, 3};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a> = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4fb6acc3f4d90809e63e519440e55b7c">zip_to_unordered_map</a>(keys, values);</div>
<div class="line"><span class="comment">// 返回无序映射 / Returns unordered_map:</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   {&quot;a&quot;, 1},</span></div>
<div class="line"><span class="comment">//   {&quot;b&quot;, 2},</span></div>
<div class="line"><span class="comment">//   {&quot;c&quot;, 3}</span></div>
<div class="line"><span class="comment">// }</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_a4fb6acc3f4d90809e63e519440e55b7c"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#a4fb6acc3f4d90809e63e519440e55b7c">toolbox::functional::zip_to_unordered_map</a></div><div class="ttdeci">CPP_TOOLBOX_EXPORT auto zip_to_unordered_map(const ContainerKeys &amp;keys, const ContainerValues &amp;values) -&gt; std::unordered_map&lt; Key, Value, Hash, KeyEqual, Alloc &gt;</div><div class="ttdoc">将两个序列压缩成无序映射 / Zip two sequences into an unordered_map</div><div class="ttdef"><b>Definition</b> functional_impl.hpp:494</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>如果键容器有重复,只使用第一次出现的键 / If keys container has duplicates, only the first occurrence is used </dd>
<dd>
键值对数量由较短的容器决定 / The number of pairs is determined by the shorter container </dd></dl>

</div>
</div>
<a id="a04b877b2a05cd06d327adb9f9bd273ea" name="a04b877b2a05cd06d327adb9f9bd273ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04b877b2a05cd06d327adb9f9bd273ea">&#9670;&#160;</a></span>zip_to_unordered_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerKeys , typename ContainerValues , typename Key , typename Value , typename Hash , typename KeyEqual , typename Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto toolbox::functional::zip_to_unordered_map </td>
          <td>(</td>
          <td class="paramtype">const ContainerKeys &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ContainerValues &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  std::unordered_map&lt; Key, Value, Hash, KeyEqual, Alloc &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>将两个序列压缩成无序映射 / Zip two sequences into an unordered_map </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerKeys</td><td>键容器类型 / Key container type </td></tr>
    <tr><td class="paramname">ContainerValues</td><td>值容器类型 / Value container type </td></tr>
    <tr><td class="paramname">Key</td><td>映射键类型(默认:ContainerKeys::value_type) / Map key type (default: ContainerKeys::value_type) </td></tr>
    <tr><td class="paramname">Value</td><td>映射值类型(默认:ContainerValues::value_type) / Map value type (default: ContainerValues::value_type) </td></tr>
    <tr><td class="paramname">Hash</td><td>键哈希函数类型 / Key hash function type </td></tr>
    <tr><td class="paramname">KeyEqual</td><td>键相等比较函数类型 / Key equality comparison function type </td></tr>
    <tr><td class="paramname">Alloc</td><td>映射分配器类型 / Map allocator type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys</td><td>键容器 / Container of keys </td></tr>
    <tr><td class="paramname">values</td><td>值容器 / Container of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含键值对的无序映射 / Unordered map containing key-value pairs</dd></dl>
<div class="fragment"><div class="line"><span class="comment">// 基本用法 / Basic usage</span></div>
<div class="line">std::vector&lt;std::string&gt; keys = {<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>};</div>
<div class="line">std::vector&lt;int&gt; values = {1, 2, 3};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> <a class="code hl_function" href="namespacetoolbox_1_1functional.html#ab987da3dae28f15d0476a73bcb249c31">map</a> = <a class="code hl_function" href="namespacetoolbox_1_1functional.html#a4fb6acc3f4d90809e63e519440e55b7c">zip_to_unordered_map</a>(keys, values);</div>
<div class="line"><span class="comment">// 返回无序映射 / Returns unordered_map:</span></div>
<div class="line"><span class="comment">// {</span></div>
<div class="line"><span class="comment">//   {&quot;a&quot;, 1},</span></div>
<div class="line"><span class="comment">//   {&quot;b&quot;, 2},</span></div>
<div class="line"><span class="comment">//   {&quot;c&quot;, 3}</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>如果键容器有重复,只使用第一次出现的键 / If keys container has duplicates, only the first occurrence is used </dd>
<dd>
键值对数量由较短的容器决定 / The number of pairs is determined by the shorter container </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae72a328600ef1342629b7fe3bab4d88b" name="ae72a328600ef1342629b7fe3bab4d88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a328600ef1342629b7fe3bab4d88b">&#9670;&#160;</a></span>MemoizedFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Signature &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class CPP_TOOLBOX_EXPORT toolbox::functional::MemoizedFunction</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>缓存函数结果的记忆化函数类 / Memoized function class that caches function results </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Signature</td><td>函数签名类型(如 int(int, std::string)) / Function signature type (e.g., int(int, std::string))</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="comment">// 创建记忆化阶乘函数 / Create memoized factorial function</span></div>
<div class="line"><a class="code hl_variable" href="namespacetoolbox_1_1functional.html#ae72a328600ef1342629b7fe3bab4d88b">MemoizedFunction</a>&lt;int(<span class="keywordtype">int</span>)&gt; fact([](<span class="keywordtype">int</span> n) {</div>
<div class="line">  <span class="keywordflow">if</span> (n &lt;= 1) <span class="keywordflow">return</span> 1;</div>
<div class="line">  <span class="keywordflow">return</span> n * fact(n-1);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> result1 = fact(5); <span class="comment">// 计算并缓存 / Computes and caches</span></div>
<div class="line"><span class="keywordtype">int</span> result2 = fact(5); <span class="comment">// 返回缓存结果 / Returns cached result</span></div>
<div class="ttc" id="anamespacetoolbox_1_1functional_html_ae72a328600ef1342629b7fe3bab4d88b"><div class="ttname"><a href="namespacetoolbox_1_1functional.html#ae72a328600ef1342629b7fe3bab4d88b">toolbox::functional::MemoizedFunction</a></div><div class="ttdeci">class CPP_TOOLBOX_EXPORT MemoizedFunction</div><div class="ttdoc">缓存函数结果的记忆化函数类 / Memoized function class that caches function results</div><div class="ttdef"><b>Definition</b> functional.hpp:820</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>线程安全实现 / Thread-safe implementation </dd>
<dd>
函数参数必须可复制且能形成有效的映射键 / Function arguments must be copyable and form valid map key </dd>
<dd>
返回类型必须可复制 / Return type must be copyable </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetoolbox.html">toolbox</a></li><li class="navelem"><a class="el" href="namespacetoolbox_1_1functional.html">functional</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
